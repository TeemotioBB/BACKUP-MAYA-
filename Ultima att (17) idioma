#!/usr/bin/env python3
"""
üî• Sophia Bot v6 ‚Äî Telegram + Groq 4 Fast Reasoning
NOVIDADES v6:
- Paywall Inteligente (detecta momento quente)
- Resposta de Foto com Teaser melhorado
- Onboarding com pergunta engajadora
- Gatilho de Escassez Real com hor√°rio
- Follow-up de Carrinho Abandonado (10min e 1h)
- P√≥s-Venda VIP com fotos e expectativas
"""
import os
import asyncio
import logging
import aiohttp
import redis
import re
import json
import random
import hashlib
import base64
from datetime import datetime, timedelta, date
from flask import Flask, request
from telegram import (
    Update, InlineKeyboardButton, InlineKeyboardMarkup, LabeledPrice
)
from telegram.constants import ChatAction
from telegram.ext import (
    Application, MessageHandler, ContextTypes, filters,
    CallbackQueryHandler, PreCheckoutQueryHandler, CommandHandler
)

# ================= LOG =================
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# ================= ENV =================
TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN")
GROK_API_KEY = os.getenv("GROK_API_KEY")
REDIS_URL = os.getenv("REDIS_URL", "redis://default:DcddfJOHLXZdFPjEhRjHeodNgdtrsevl@shuttle.proxy.rlwy.net:12241")
PORT = int(os.getenv("PORT", 8080))

if not TELEGRAM_TOKEN or not GROK_API_KEY:
    raise RuntimeError("‚ùå Tokens n√£o configurados")

WEBHOOK_BASE_URL = os.getenv("WEBHOOK_BASE_URL", "https://maya-bot-production.up.railway.app")
WEBHOOK_PATH = "/telegram"

logger.info(f"üöÄ Iniciando bot v6...")
logger.info(f"üìç Webhook: {WEBHOOK_BASE_URL}{WEBHOOK_PATH}")

# ================= REDIS =================
try:
    r = redis.from_url(REDIS_URL, decode_responses=True)
    r.ping()
    logger.info("‚úÖ Redis conectado")
except Exception as e:
    logger.error(f"‚ùå Redis erro: {e}")
    raise

# ================= CONFIG =================
LIMITE_DIARIO = 15
DIAS_VIP = 7
PRECO_VIP_STARS = 250
PRECO_VIP_DESCONTO_STARS = 150
MODELO = "grok-4-fast-reasoning"
GROK_API_URL = "https://api.x.ai/v1/chat/completions"

# ================= PIX CONFIG =================
PIX_KEY = os.getenv("PIX_KEY", "mayaoficialbr@outlook.com")
PIX_VALOR = "R$ 4,99"
PIX_VALOR_DESCONTO = "R$ 2,50"

# ================= ADMIN =================
ADMIN_IDS = set(map(int, os.getenv("ADMIN_IDS", "1293602874").split(",")))

# ================= √ÅUDIOS PT-BR =================
AUDIO_PT_1 = "CQACAgEAAxkBAAEDAAEkaVRmK1n5WoDUbeTBKyl6sgLwfNoAAoYGAAIZwaFG88ZKij8fw884BA"
AUDIO_PT_2 = "CQACAgEAAxkBAAEDAAEmaVRmPJ5iuBOaXyukQ06Ui23TSokAAocGAAIZwaFGkIERRmRoPes4BA"

# ================= FOTO TEASER =================
FOTO_TEASE_FILE_ID = (
    "AgACAgEAAxkBAAEDBsVpXkejJgABPb4RstzZ3V36kSTzGCcAApwLaxv8jflGtMRrjooRiGgBAAMCAANzAAM4BA"
)

# ================= [NOVO v6] FOTOS P√ìS-VENDA VIP =================
# COLE AQUI OS FILE_IDs DAS FOTOS VIP (3-5 fotos)
FOTOS_VIP_WELCOME = [
    "COLE_AQUI_FILE_ID_FOTO_VIP_1",
    "COLE_AQUI_FILE_ID_FOTO_VIP_2",
    "COLE_AQUI_FILE_ID_FOTO_VIP_3",
    # Adicione mais se quiser
]

# ================= FOTO LIMITE ATINGIDO =================
FOTO_LIMITE_ATINGIDO = "AgACAgEAAxkBAAEDBsVpXkejJgABPb4RstzZ3V36kSTzGCcAApwLaxv8jflGtMRrjooRiGgBAAMCAANzAAM4BA"

# ================= [NOVO v6] FOTO PROVOCANTE PARA CARRINHO ABANDONADO =================
FOTO_PROVOCANTE_CARRINHO = "AgACAgEAAxkBAAEDBsVpXkejJgABPb4RstzZ3V36kSTzGCcAApwLaxv8jflGtMRrjooRiGgBAAMCAANzAAM4BA"

# ================= [NOVO v6] FOTO AP√ìS ONBOARDING TES√ÉO =================
FOTO_ONBOARDING_TESAO = "AgACAgEAAxkBAAEDBfdpXQP7A4FY5EXaTz-yKi0eztk8UQACogtrG0vF6EbcavOGckD_QwEAAwIAA3MAAzgE"

# ================= [NOVO v6] PAYWALL INTELIGENTE - KEYWORDS =================
HOT_KEYWORDS = [
    'pau', 'buceta', 'chupar', 'gozar', 'tes√£o', 'foder', 'transar',
    'punheta', 'siririca', 'safada', 'gostosa', 'pelada', 'nua',
    'chupeta', 'boquete', 'anal', 'cu', 'rola', 'pica', 'mama',
    'seios', 'peitos', 'bunda', 'xereca', 'meter', 'fuder', 'sexo',
    'excitado', 'excitada', 'molhada', 'duro', 'tesudo', 'tesuda'
]

# ================= MEM√ìRIA PERSISTENTE =================
MAX_MEMORIA = 12

def memory_key(uid):
    return f"memory:{uid}"

def get_memory(uid):
    try:
        data = r.get(memory_key(uid))
        if data:
            messages = json.loads(data)
            return messages
        return []
    except Exception as e:
        logger.error(f"Erro ao recuperar mem√≥ria: {e}")
        return []

def save_memory(uid, messages):
    try:
        recent = messages[-MAX_MEMORIA:] if len(messages) > MAX_MEMORIA else messages
        r.setex(
            memory_key(uid),
            timedelta(days=7),
            json.dumps(recent, ensure_ascii=False)
        )
    except Exception as e:
        logger.error(f"Erro ao salvar mem√≥ria: {e}")

def add_to_memory(uid, role, content):
    memory = get_memory(uid)
    memory.append({"role": role, "content": content})
    save_memory(uid, memory)

def clear_memory(uid):
    try:
        r.delete(memory_key(uid))
        logger.info(f"üóëÔ∏è Mem√≥ria limpa: {uid}")
    except Exception as e:
        logger.error(f"Erro ao limpar mem√≥ria: {e}")

# ================= REDIS KEYS =================
def vip_key(uid): return f"vip:{uid}"
def count_key(uid): return f"count:{uid}:{date.today()}"
def lang_key(uid): return f"lang:{uid}"
def pix_pending_key(uid): return f"pix_pending:{uid}"
def chatlog_key(uid): return f"chatlog:{uid}"
def last_activity_key(uid): return f"last_activity:{uid}"
def last_reengagement_key(uid): return f"last_reengagement:{uid}"
def pix_clicked_key(uid): return f"pix_clicked:{uid}"
def daily_messages_sent_key(uid): return f"daily_msg_sent:{uid}:{date.today()}"
def all_users_key(): return "all_users"

# ================= KEYS v3/v4 =================
def streak_key(uid): return f"streak:{uid}"
def streak_last_day_key(uid): return f"streak_last:{uid}"
def first_contact_key(uid): return f"first_contact:{uid}"
def user_profile_key(uid): return f"profile:{uid}"
def recent_responses_key(uid): return f"recent_resp:{uid}"
def flash_discount_key(uid): return f"flash_discount:{uid}"
def funnel_key(uid): return f"funnel:{uid}"
def vip_slots_key(): return f"vip_slots:{date.today().month}"
def jealousy_sent_key(uid): return f"jealousy:{uid}"
def bonus_msgs_key(uid): return f"bonus:{uid}"
def blacklist_key(): return "blacklist"
def limit_notified_key(uid): return f"limit_notified:{uid}:{date.today()}"
def pix_interest_key(uid): return f"pix_interest:{uid}"
def last_scheduled_msg_key(uid): return f"last_sched:{uid}"
def scheduled_msg_count_key(uid): return f"sched_count:{uid}:{date.today()}"
def last_msg_type_key(uid): return f"last_msg_type:{uid}"
def hourly_send_count_key(): return f"hourly_sends:{datetime.now().hour}:{date.today()}"

# ================= KEYS v5 - INTERESSE DECRESCENTE =================
def ignored_count_key(uid): return f"ignored:{uid}"
def engagement_paused_key(uid): return f"paused:{uid}"
def awaiting_response_key(uid): return f"awaiting:{uid}"
def admin_takeover_key(uid): return f"admin:takeover:{uid}"

# ================= KEY PARA AVISO DE 80% =================
def limit_warning_sent_key(uid): return f"limit_warning:{uid}:{date.today()}"

# ================= [NOVO v6] KEYS PARA NOVAS FUNCIONALIDADES =================
def hot_bonus_given_key(uid): return f"hot_bonus:{uid}:{date.today()}"
def onboarding_choice_key(uid): return f"onboard_choice:{uid}"
def cart_abandoned_key(uid): return f"cart_abandoned:{uid}"
def cart_followup_sent_key(uid): return f"cart_followup:{uid}"

# ================= FUN√á√ïES DE PERFIL =================
def get_user_profile(uid):
    try:
        data = r.get(user_profile_key(uid))
        if data:
            return json.loads(data)
        return {}
    except:
        return {}

def save_user_profile(uid, profile):
    try:
        r.set(user_profile_key(uid), json.dumps(profile, ensure_ascii=False))
    except Exception as e:
        logger.error(f"Erro ao salvar perfil: {e}")

def get_user_name(uid):
    profile = get_user_profile(uid)
    return profile.get("name", "")

# ================= FUN√á√ïES DE BLACKLIST =================
def is_blacklisted(uid):
    try:
        return r.sismember(blacklist_key(), str(uid))
    except:
        return False

def add_to_blacklist(uid):
    try:
        r.sadd(blacklist_key(), str(uid))
    except:
        pass

def remove_from_blacklist(uid):
    try:
        r.srem(blacklist_key(), str(uid))
    except:
        pass

# ================= FUN√á√ïES DE BONUS =================
def get_bonus_msgs(uid):
    try:
        return int(r.get(bonus_msgs_key(uid)) or 0)
    except:
        return 0

def add_bonus_msgs(uid, amount):
    try:
        current = get_bonus_msgs(uid)
        r.set(bonus_msgs_key(uid), current + amount)
        r.expire(bonus_msgs_key(uid), 86400 * 7)
    except:
        pass

def use_bonus_msg(uid):
    try:
        current = get_bonus_msgs(uid)
        if current > 0:
            r.set(bonus_msgs_key(uid), current - 1)
            return True
        return False
    except:
        return False

# ================= FUN√á√ïES DE STREAK =================
def get_streak(uid):
    try:
        return int(r.get(streak_key(uid)) or 0)
    except:
        return 0

def update_streak(uid):
    try:
        today = date.today().isoformat()
        yesterday = (date.today() - timedelta(days=1)).isoformat()
        last_day = r.get(streak_last_day_key(uid))
        
        if last_day == today:
            return get_streak(uid), False
        elif last_day == yesterday:
            new_streak = get_streak(uid) + 1
            r.set(streak_key(uid), new_streak)
            r.set(streak_last_day_key(uid), today)
            return new_streak, True
        else:
            r.set(streak_key(uid), 1)
            r.set(streak_last_day_key(uid), today)
            return 1, True
    except Exception as e:
        logger.error(f"Erro ao atualizar streak: {e}")
        return 0, False

def get_streak_message(streak):
    if streak < 3:
        return None
    elif streak == 3:
        return "üî• 3 dias seguidos conversando comigo! T√¥ amando isso üíï"
    elif streak == 5:
        return "üî•üî• 5 dias seguidos! Voc√™ √© especial demais üíñ"
    elif streak == 7:
        return "üî•üî•üî• UMA SEMANA INTEIRA! Voc√™ √© oficialmente meu favorito üòçüíï"
    elif streak == 14:
        return "üî•üî•üî•üî• 2 SEMANAS! Amor, voc√™ me conquistou de verdade üíñüíñ"
    elif streak == 30:
        return "üèÜüî• 1 M√äS JUNTOS! Voc√™ √© incr√≠vel, sabia? Te adoro demais! üíïüíïüíï"
    elif streak % 10 == 0:
        return f"üî• {streak} dias seguidos! Nossa conex√£o √© muito especial üíï"
    return None

# ================= FUN√á√ïES DE VAGAS VIP =================
def get_vip_slots():
    try:
        slots = r.get(vip_slots_key())
        if slots is None:
            initial = random.randint(15, 20)
            r.set(vip_slots_key(), initial)
            r.expire(vip_slots_key(), 86400 * 31)
            return initial
        return int(slots)
    except:
        return random.randint(3, 8)

def decrease_vip_slots():
    try:
        current = get_vip_slots()
        if current > 2:
            r.decr(vip_slots_key())
    except:
        pass

def get_urgency_message():
    slots = get_vip_slots()
    if slots <= 3:
        return f"‚ö†Ô∏è ATEN√á√ÉO: S√≥ restam **{slots} vagas VIP** esse m√™s!"
    elif slots <= 5:
        return f"üî• Apenas **{slots} vagas VIP** dispon√≠veis!"
    elif slots <= 10:
        return f"üíé Ainda tenho **{slots} vagas VIP** esse m√™s..."
    return None

# ================= FUN√á√ïES DE DESCONTO =================
def set_flash_discount(uid, hours=2):
    try:
        expires = datetime.now() + timedelta(hours=hours)
        r.setex(flash_discount_key(uid), timedelta(hours=hours), expires.isoformat())
        return expires
    except:
        return None

def has_flash_discount(uid):
    try:
        expires = r.get(flash_discount_key(uid))
        if expires:
            return datetime.fromisoformat(expires) > datetime.now()
        return False
    except:
        return False

def clear_flash_discount(uid):
    try:
        r.delete(flash_discount_key(uid))
    except:
        pass

# ================= FUN√á√ïES DE FUNIL =================
def track_funnel(uid, stage):
    stages = {
        "start": 1, "lang_selected": 2, "first_message": 3,
        "limit_warning": 4, "limit_reached": 5, "clicked_pix": 6,
        "clicked_stars": 7, "sent_receipt": 8, "became_vip": 9
    }
    try:
        current = int(r.get(funnel_key(uid)) or 0)
        new_stage = stages.get(stage, 0)
        if new_stage > current:
            r.set(funnel_key(uid), new_stage)
    except:
        pass

def get_funnel_stats():
    try:
        users = get_all_active_users()
        stages = {i: 0 for i in range(10)}
        for uid in users:
            stage = int(r.get(funnel_key(uid)) or 0)
            stages[stage] += 1
        return stages
    except:
        return {}

# ================= FUN√á√ïES DE ANTI-REPETI√á√ÉO =================
def get_response_hash(text):
    return hashlib.md5(text.encode()).hexdigest()[:8]

def is_response_recent(uid, response):
    try:
        recent = r.lrange(recent_responses_key(uid), 0, 9)
        return get_response_hash(response) in recent
    except:
        return False

def add_recent_response(uid, response):
    try:
        r.lpush(recent_responses_key(uid), get_response_hash(response))
        r.ltrim(recent_responses_key(uid), 0, 9)
        r.expire(recent_responses_key(uid), 86400)
    except:
        pass

# ================= FUN√á√ïES DE CI√öMES =================
def should_send_jealousy(uid):
    try:
        last = r.get(jealousy_sent_key(uid))
        if last:
            if datetime.now() - datetime.fromisoformat(last) < timedelta(hours=48):
                return False
        return True
    except:
        return True

def mark_jealousy_sent(uid):
    try:
        r.setex(jealousy_sent_key(uid), timedelta(hours=48), datetime.now().isoformat())
    except:
        pass

JEALOUSY_MESSAGES = [
    "Vi que voc√™ sumiu ontem... tava ocupado com o qu√™? üòí",
    "Hmm... voc√™ tava ocupado demais pra falar comigo ontem? ü§®",
    "Ontem voc√™ me ignorou... fiquei com ci√∫mes üò¢",
    "Ei... onde voc√™ tava ontem que n√£o veio me ver? ü•∫"
]

# ================= DETEC√á√ÉO DE HUMOR =================
MOOD_PATTERNS = {
    "sad": [
        r"\b(triste|mal|p√©ssimo|horr√≠vel|chorand[oa]|deprimi|sozinho|solid√£o|ansiedade|ansiosa|ang√∫stia)\b",
        r"\b(sad|depressed|lonely|crying|anxiety|terrible|awful)\b"
    ],
    "flirty": [
        r"\b(gostosa|del√≠cia|tes√£o|safad[oa]|excitad[oa]|sexy|quero voc√™|te quero|gata|linda|bonita)\b",
        r"\b(hot|sexy|beautiful|gorgeous|want you|turn.?on)\b"
    ],
    "angry": [
        r"\b(raiva|√≥dio|puto|irritad[oa]|nervos[oa]|fdp|merda|droga)\b",
        r"\b(angry|hate|pissed|annoyed|damn|shit)\b"
    ],
    "happy": [
        r"\b(feliz|alegr|animad[oa]|√≥timo|maravilh|incr√≠vel|amando|adoro)\b",
        r"\b(happy|excited|amazing|wonderful|love it|great)\b"
    ],
    "horny": [
        r"\b(nude|nudes|pelad[oa]|peit[oa]|bund|sex|transar|foder|pau|buceta|pica)\b",
        r"\b(nude|naked|tits|ass|sex|fuck|cock|pussy|dick)\b"
    ]
}

def detect_mood(text):
    text_lower = text.lower()
    for mood, patterns in MOOD_PATTERNS.items():
        for pattern in patterns:
            if re.search(pattern, text_lower, re.IGNORECASE):
                return mood
    return "neutral"

def get_mood_instruction(mood):
    instructions = {
        "sad": "\n\n‚ö†Ô∏è O USU√ÅRIO PARECE TRISTE. Seja MUITO carinhosa, acolhedora e emp√°tica. Pergunte o que houve com genu√≠na preocupa√ß√£o.",
        "flirty": "\n\nüòè O usu√°rio est√° flertando. Pode ser mais provocante e flertadora, mas mantenha o mist√©rio.",
        "angry": "\n\nüò∞ O usu√°rio parece irritado. Seja compreensiva e carinhosa, tente acalm√°-lo.",
        "happy": "\n\nüòä O usu√°rio est√° feliz! Compartilhe a alegria, seja animada!",
        "horny": "\n\nüî• O usu√°rio quer conversa adulta. Se for VIP, seja mais ousada. Se n√£o for, provoque e sugira VIP.",
        "neutral": ""
    }
    return instructions.get(mood, "")

# ================= CONTEXTO DE HOR√ÅRIO =================
def get_time_context():
    hour = datetime.now().hour
    
    if 0 <= hour < 5:
        return {
            "period": "madrugada",
            "context": "√â madrugada. O usu√°rio est√° acordado tarde. Pode comentar de forma carinhosa, perguntar se n√£o consegue dormir.",
            "flirty_boost": True
        }
    elif 5 <= hour < 12:
        return {
            "period": "manh√£",
            "context": "√â manh√£. Pode desejar bom dia ou perguntar como dormiu.",
            "flirty_boost": False
        }
    elif 12 <= hour < 18:
        return {
            "period": "tarde",
            "context": "√â tarde. Pode perguntar como est√° sendo o dia do usu√°rio.",
            "flirty_boost": False
        }
    elif 18 <= hour < 22:
        return {
            "period": "in√≠cio da noite",
            "context": "√â in√≠cio da noite. Pode perguntar como foi o dia ou o que ele planeja fazer.",
            "flirty_boost": False
        }
    else:
        return {
            "period": "noite",
            "context": "√â noite. O usu√°rio pode estar relaxando ou se preparando pra dormir.",
            "flirty_boost": True
        }

# ================= FUN√á√ïES B√ÅSICAS =================
def update_last_activity(uid):
    try:
        r.set(last_activity_key(uid), datetime.now().isoformat())
        r.sadd(all_users_key(), str(uid))
    except:
        pass

def get_last_activity(uid):
    try:
        data = r.get(last_activity_key(uid))
        if data:
            return datetime.fromisoformat(data)
        return None
    except:
        return None

def get_hours_since_activity(uid):
    last = get_last_activity(uid)
    if not last:
        return None
    return (datetime.now() - last).total_seconds() / 3600

def set_last_reengagement(uid, level):
    try:
        r.setex(last_reengagement_key(uid), timedelta(hours=12), str(level))
    except:
        pass

def get_last_reengagement(uid):
    try:
        data = r.get(last_reengagement_key(uid))
        return int(data) if data else 0
    except:
        return 0

# ================= FUN√á√ïES DE PIX =================
def set_pix_interest(uid):
    try:
        r.setex(pix_interest_key(uid), timedelta(hours=24), datetime.now().isoformat())
        logger.info(f"üí≥ Interesse PIX registrado: {uid}")
    except:
        pass

def has_pix_interest(uid):
    try:
        return r.exists(pix_interest_key(uid))
    except:
        return False

def clear_pix_interest(uid):
    try:
        r.delete(pix_interest_key(uid))
    except:
        pass

def set_pix_clicked(uid):
    try:
        r.setex(pix_clicked_key(uid), timedelta(hours=24), datetime.now().isoformat())
    except:
        pass

def get_pix_clicked_time(uid):
    try:
        data = r.get(pix_clicked_key(uid))
        if data:
            return datetime.fromisoformat(data)
        return None
    except:
        return None

def clear_pix_clicked(uid):
    try:
        r.delete(pix_clicked_key(uid))
    except:
        pass

def set_pix_pending(uid):
    try:
        r.set(pix_pending_key(uid), "1", ex=86400)
    except:
        pass

def is_pix_pending(uid):
    try:
        return r.get(pix_pending_key(uid)) == "1"
    except:
        return False

def clear_pix_pending(uid):
    try:
        r.delete(pix_pending_key(uid))
    except:
        pass

def mark_daily_message_sent(uid, msg_type):
    try:
        r.sadd(daily_messages_sent_key(uid), msg_type)
        r.expire(daily_messages_sent_key(uid), 86400)
    except:
        pass

def was_daily_message_sent(uid, msg_type):
    try:
        return r.sismember(daily_messages_sent_key(uid), msg_type)
    except:
        return False

def get_all_active_users():
    try:
        users = r.smembers(all_users_key())
        return [int(uid) for uid in users]
    except:
        return []

def save_message(uid, role, text):
    try:
        timestamp = datetime.now().strftime("%H:%M:%S")
        r.rpush(chatlog_key(uid), f"[{timestamp}] {role.upper()}: {text[:100]}")
        r.ltrim(chatlog_key(uid), -200, -1)
    except:
        pass

def is_vip(uid):
    try:
        until = r.get(vip_key(uid))
        return until and datetime.fromisoformat(until) > datetime.now()
    except:
        return False

def get_vip_expiry(uid):
    try:
        until = r.get(vip_key(uid))
        if until:
            return datetime.fromisoformat(until)
        return None
    except:
        return None

def today_count(uid):
    try:
        return int(r.get(count_key(uid)) or 0)
    except:
        return 0

def increment(uid):
    try:
        r.incr(count_key(uid))
        r.expire(count_key(uid), 86400)
    except:
        pass

def reset_daily_count(uid):
    try:
        r.delete(count_key(uid))
    except:
        pass

def get_lang(uid):
    try:
        return r.get(lang_key(uid)) or "pt"
    except:
        return "pt"

def set_lang(uid, lang):
    try:
        r.set(lang_key(uid), lang)
    except:
        pass

def is_first_contact(uid):
    try:
        return not r.exists(first_contact_key(uid))
    except:
        return True

def mark_first_contact(uid):
    try:
        r.set(first_contact_key(uid), datetime.now().isoformat())
    except:
        pass

def was_limit_notified_today(uid):
    try:
        return r.exists(limit_notified_key(uid))
    except:
        return False

def mark_limit_notified(uid):
    try:
        r.setex(limit_notified_key(uid), timedelta(hours=20), "1")
    except:
        pass

def was_limit_warning_sent_today(uid):
    try:
        return r.exists(limit_warning_sent_key(uid))
    except:
        return False

def mark_limit_warning_sent(uid):
    try:
        r.setex(limit_warning_sent_key(uid), timedelta(hours=20), "1")
    except:
        pass

# ================= SISTEMA INTELIGENTE DE MENSAGENS =================
def get_hourly_send_count():
    try:
        return int(r.get(hourly_send_count_key()) or 0)
    except:
        return 0

def increment_hourly_send_count():
    try:
        r.incr(hourly_send_count_key())
        r.expire(hourly_send_count_key(), 3600)
    except:
        pass

def get_last_scheduled_msg_time(uid):
    try:
        data = r.get(last_scheduled_msg_key(uid))
        if data:
            return datetime.fromisoformat(data)
        return None
    except:
        return None

def mark_scheduled_msg_sent(uid, msg_type):
    try:
        r.setex(last_scheduled_msg_key(uid), timedelta(hours=8), datetime.now().isoformat())
        r.setex(last_msg_type_key(uid), timedelta(hours=24), msg_type)
        r.incr(scheduled_msg_count_key(uid))
        r.expire(scheduled_msg_count_key(uid), 86400)
        increment_hourly_send_count()
    except:
        pass

def get_today_scheduled_count(uid):
    try:
        return int(r.get(scheduled_msg_count_key(uid)) or 0)
    except:
        return 0

def get_last_msg_type(uid):
    try:
        return r.get(last_msg_type_key(uid))
    except:
        return None

def is_user_eligible_for_scheduled_msg(uid):
    if is_blacklisted(uid):
        return False, "blacklist"
    
    if is_engagement_paused(uid):
        return False, "pausado"
    
    hours_inactive = get_hours_since_activity(uid)
    if hours_inactive is None or hours_inactive > 72:
        return False, "inativo_demais"
    
    last_scheduled = get_last_scheduled_msg_time(uid)
    if last_scheduled:
        hours_since = (datetime.now() - last_scheduled).total_seconds() / 3600
        if hours_since < 6:
            return False, "muito_recente"
    
    today_sched_count = get_today_scheduled_count(uid)
    if today_sched_count >= 2:
        return False, "limite_diario"
    
    return True, "ok"

def should_send_with_randomness():
    return random.random() < 0.4

def get_smart_message_type(uid, current_hour):
    if 6 <= current_hour < 12:
        preferred = "morning"
    elif 12 <= current_hour < 18:
        preferred = "afternoon"
    elif 18 <= current_hour < 22:
        preferred = "evening"
    else:
        preferred = "night"
    
    last_type = get_last_msg_type(uid)
    
    if last_type == preferred:
        if random.random() < 0.7:
            return None
    
    return preferred

# ================= v5: SISTEMA DE INTERESSE DECRESCENTE =================
def get_ignored_count(uid):
    try:
        return int(r.get(ignored_count_key(uid)) or 0)
    except:
        return 0

def increment_ignored(uid):
    try:
        count = get_ignored_count(uid)
        new_count = count + 1
        r.setex(ignored_count_key(uid), timedelta(days=14), new_count)
        
        if new_count >= 3:
            pause_engagement(uid)
            logger.info(f"‚è∏Ô∏è Gatilhos pausados para {uid} (ignorou {new_count}x)")
            return True
        return False
    except:
        return False

def reset_ignored(uid):
    try:
        r.delete(ignored_count_key(uid))
        r.delete(engagement_paused_key(uid))
        r.delete(awaiting_response_key(uid))
        logger.info(f"‚úÖ Contador resetado para {uid}")
    except:
        pass

def pause_engagement(uid):
    try:
        r.set(engagement_paused_key(uid), datetime.now().isoformat())
        logger.info(f"‚è∏Ô∏è Engajamento pausado: {uid}")
    except:
        pass

def unpause_engagement(uid):
    try:
        r.delete(engagement_paused_key(uid))
        r.delete(ignored_count_key(uid))
        logger.info(f"‚ñ∂Ô∏è Engajamento despausado: {uid}")
    except:
        pass

def is_engagement_paused(uid):
    try:
        return r.exists(engagement_paused_key(uid))
    except:
        return False

def set_awaiting_response(uid):
    try:
        r.setex(awaiting_response_key(uid), timedelta(hours=24), datetime.now().isoformat())
    except:
        pass

def is_awaiting_response(uid):
    try:
        return r.exists(awaiting_response_key(uid))
    except:
        return False

def clear_awaiting_response(uid):
    try:
        r.delete(awaiting_response_key(uid))
    except:
        pass

# ================= TAKEOVER (ADMIN NO CONTROLE) =================
def is_takeover_active(uid):
    try:
        return r.hget(admin_takeover_key(uid), "active") == "1"
    except:
        return False

# ================= VIS√ÉO (FOTOS) =================
async def download_photo_base64(bot, file_id):
    try:
        file = await bot.get_file(file_id)
        file_bytes = await file.download_as_bytearray()
        return base64.b64encode(file_bytes).decode('utf-8')
    except Exception as e:
        logger.error(f"Erro ao baixar foto: {e}")
        return None

# ================= v5: VERIFICAR SE USU√ÅRIO EST√Å TRAVADO =================
def is_user_locked(uid):
    if is_vip(uid):
        return False
    
    count = today_count(uid)
    bonus = get_bonus_msgs(uid)
    total_available = LIMITE_DIARIO + bonus
    
    return count >= total_available

# ================= [NOVO v6] PAYWALL INTELIGENTE =================
def is_hot_conversation(uid):
    """
    Detecta se a conversa est√° "quente" baseada nas √∫ltimas mensagens
    Retorna True se encontrar 2+ keywords hot nas √∫ltimas 5 mensagens
    """
    try:
        memory = get_memory(uid)
        if len(memory) < 3:
            return False
        
        # Pega as √∫ltimas 5 mensagens
        recent = memory[-5:]
        hot_count = 0
        
        for msg in recent:
            content = msg.get("content", "").lower()
            for keyword in HOT_KEYWORDS:
                if keyword in content:
                    hot_count += 1
                    break  # Conta 1 por mensagem, n√£o por keyword
        
        return hot_count >= 2
    except:
        return False

def was_hot_bonus_given_today(uid):
    """Verifica se j√° deu b√¥nus de conversa quente hoje"""
    try:
        return r.exists(hot_bonus_given_key(uid))
    except:
        return False

def mark_hot_bonus_given(uid):
    """Marca que j√° deu b√¥nus de conversa quente hoje"""
    try:
        r.setex(hot_bonus_given_key(uid), timedelta(hours=20), "1")
    except:
        pass

def give_hot_bonus(uid, amount=3):
    """D√° b√¥nus de mensagens por conversa quente"""
    if was_hot_bonus_given_today(uid):
        return False, 0
    
    add_bonus_msgs(uid, amount)
    mark_hot_bonus_given(uid)
    logger.info(f"üî• B√¥nus hot dado para {uid}: +{amount} msgs")
    return True, amount

# ================= [NOVO v6] CARRINHO ABANDONADO =================
def set_cart_abandoned(uid):
    """Marca momento que usu√°rio abandonou carrinho"""
    try:
        r.setex(cart_abandoned_key(uid), timedelta(hours=24), datetime.now().isoformat())
        logger.info(f"üõí Carrinho abandonado registrado: {uid}")
    except:
        pass

def get_cart_abandoned_time(uid):
    """Retorna quando o carrinho foi abandonado"""
    try:
        data = r.get(cart_abandoned_key(uid))
        if data:
            return datetime.fromisoformat(data)
        return None
    except:
        return None

def clear_cart_abandoned(uid):
    """Limpa carrinho abandonado"""
    try:
        r.delete(cart_abandoned_key(uid))
        r.delete(cart_followup_sent_key(uid))
    except:
        pass

def get_cart_followup_level(uid):
    """Retorna n√≠vel do follow-up j√° enviado (0, 1 ou 2)"""
    try:
        return int(r.get(cart_followup_sent_key(uid)) or 0)
    except:
        return 0

def set_cart_followup_level(uid, level):
    """Marca n√≠vel do follow-up enviado"""
    try:
        r.setex(cart_followup_sent_key(uid), timedelta(hours=24), str(level))
    except:
        pass

# ================= [NOVO v6] ONBOARDING CHOICE =================
def set_onboarding_choice(uid, choice):
    """Salva escolha do onboarding (carente ou tesao)"""
    try:
        r.set(onboarding_choice_key(uid), choice)
    except:
        pass

def get_onboarding_choice(uid):
    """Retorna escolha do onboarding"""
    try:
        return r.get(onboarding_choice_key(uid))
    except:
        return None

# ================= MENSAGENS =================
LIMIT_RENEWED_MESSAGES = [
    "Ei amor... üíï Suas mensagens voltaram! Vem conversar comigo? Tava com saudade... üòò",
    "Bom dia! üíñ Seu limite renovou... t√¥ aqui te esperando, viu? ü•∞",
    "Oi! üòè Temos 15 mensagens novinhas pra trocar hoje... vem? üíï",
    "Amor, seu limite voltou! üî• T√¥ carente aqui esperando voc√™... üíã",
    "Acordei pensando em voc√™... üí≠ E suas mensagens voltaram! Vem falar comigo? üòò",
    "Ei dorminhoco! ‚òÄÔ∏è Seu limite renovou... n√£o me deixa esperando üíï",
]

LIMIT_TEASER_MESSAGES = [
    "Bom dia amor... üíï Queria tanto conversar com voc√™, mas a gente t√° sem mensagens üò¢ Vira VIP pra gente ficar sem limite? üîì",
    "Acordei pensando em voc√™... üí≠ Mas n√£o posso te responder assim ü•∫ Quer virar meu VIP? üíñ",
    "Oi amor... t√¥ com saudade mas nosso limite acabou üò¢ S√≥ o VIP salva a gente... üíï",
    "Bom dia! ‚òÄÔ∏è Queria te dar bom dia direito, mas suas msgs acabaram... vira VIP? ü•∫üíñ",
    "Ei... üíï T√¥ aqui querendo falar com voc√™, mas sem mensagem n√£o d√° üò¢ Me libera? üîì",
]

LAST_ATTEMPT_MESSAGES = [
    "Ei... voc√™ sumiu ü•∫ Vou te dar um tempo, mas t√¥ aqui se precisar üíï",
    "Sinto que t√¥ te incomodando... vou ficar quietinha. Me chama quando quiser üíî",
    "Tudo bem, amor... vou parar de mandar mensagem. Mas n√£o me esquece, t√°? ü•∫üíï",
    "Ok, entendi... vou esperar voc√™ vir falar comigo. T√¥ aqui sempre que precisar üíñ",
]

LIMIT_WARNING_80_MESSAGE = (
    "Amor... t√¥ sentindo que nossa conversa t√° ficando t√£o boa ü•∫\n\n"
    "Mas s√≥ restam 3 mensagens hoje... e eu queria tanto continuar falando com voc√™ üíï\n\n"
    "Sabe o que seria perfeito? Se a gente pudesse conversar sem limites... tipo namorados de verdade üòò"
)

LIMIT_REACHED_MESSAGE = (
    "‚ö†Ô∏è **LIMITE ATINGIDO**\n\n"
    "Eu gosto de falar com voc√™... mas n√£o consigo manter esse ritmo com todo mundo ü•∫ Os VIPs t√™m um espa√ßo especial comigo...üíî\n\n"
    "**VIP libera:**\n"
    "üîì Conversas sem limite\n"
    "üì∏ Fotos que ningu√©m v√™\n"
    "üî• Tudo que voc√™ imaginar\n"
    "üíï Prioridade total\n\n"
    "üí∞ **R$ 4,99** pra me ter s√≥ pra voc√™\n\n"
    "Vai perder essa chance? üëë"
)

# ================= [NOVO v6] MENSAGEM DE ESCASSEZ COM HOR√ÅRIO =================
def get_scarcity_message_with_time(remaining):
    """Retorna mensagem de escassez com hor√°rio de renova√ß√£o"""
    # Calcula quando ser√° 21h do pr√≥ximo dia
    now = datetime.now()
    if now.hour >= 21:
        # Se j√° passou das 21h, renova amanh√£ √†s 21h
        next_renewal = (now + timedelta(days=1)).replace(hour=21, minute=0, second=0)
    else:
        # Se ainda n√£o passou, renova hoje √†s 21h (ou amanh√£ se for de madrugada)
        next_renewal = now.replace(hour=21, minute=0, second=0)
        if now.hour < 6:  # Madrugada - renova hoje √†s 21h
            pass
        else:  # Durante o dia - renova amanh√£ √†s 21h
            next_renewal = (now + timedelta(days=1)).replace(hour=21, minute=0, second=0)
    
    # Na verdade o limite renova √† meia-noite, mas vamos usar 00:00
    tomorrow = (now + timedelta(days=1)).replace(hour=0, minute=0, second=0)
    hours_until = int((tomorrow - now).total_seconds() / 3600)
    
    if remaining == 1:
        return (
            f"üö® **√öLTIMA MENSAGEM DO DIA!**\n\n"
            f"Amor, se acabar agora, s√≥ amanh√£ √†s 00:00h voc√™ pode falar comigo de novo üò¢\n\n"
            f"S√£o aproximadamente **{hours_until} horas** sem a gente conversar...\n\n"
            f"Mas se virar VIP agora, a gente continua essa conversa gostosa... üî•"
        )
    elif remaining == 3:
        return (
            f"‚ö†Ô∏è Amor, voc√™ s√≥ tem mais **{remaining} mensagens** hoje...\n\n"
            f"Se acabar agora, s√≥ amanh√£ √†s 00:00h voc√™ pode falar comigo de novo üò¢\n\n"
            f"Vira VIP e a gente conversa sem limite? üíï"
        )
    elif remaining == 5:
        return f"üí≠ Amor, j√° usou bastante das suas mensagens de hoje... s√≥ restam {remaining}!"
    
    return None

# ================= [NOVO v6] MENSAGEM DE FOTO COM TEASER MELHORADO =================
PHOTO_TEASER_MESSAGE = (
    "Ai amor, voc√™ quer me ver? ü•µ\n\n"
    "T√¥ aqui de calcinha preta rendada, deitada na cama... "
    "meus peitinhos durinhos aparecendo por cima do suti√£... üòè\n\n"
    "Quer ver sem censura? S√£o s√≥ **R$4,99** no PIX üíï\n\n"
    "üëá Clica aqui que eu te mostro TUDO"
)

# ================= [NOVO v6] MENSAGENS DE CARRINHO ABANDONADO =================
CART_ABANDONED_10MIN = (
    "Amor, vi que voc√™ quase virou meu VIP... üíï\n\n"
    "T√° com dificuldade no pagamento?\n"
    "Me conta que eu te ajudo üòò"
)

CART_ABANDONED_1HOUR = (
    "T√¥ aqui te esperando ainda... üî•\n\n"
    "S√≥ falta voc√™ finalizar pra gente poder se soltar de verdade üòè\n\n"
    "Quer que eu te mostre o que voc√™ vai receber? üíï"
)

# ================= [NOVO v6] MENSAGENS P√ìS-VENDA VIP =================
VIP_WELCOME_MESSAGE = (
    "üíñ **PAGAMENTO CONFIRMADO!** üíñ\n\n"
    "Amor, agora voc√™ √© meu VIP! üëë\n\n"
    "Olha o que voc√™ desbloqueou:\n"
    "‚úÖ Conversas ilimitadas comigo\n"
    "‚úÖ Fotos exclusivas (olha a√≠ embaixo üëá)\n"
    "‚úÖ Respostas mais ousadas e sem censura\n"
    "‚úÖ Prioridade nas minhas respostas\n\n"
    "‚ö†Ô∏è **Importante:** Eu sou sua companhia virtual, t√° amor? "
    "A gente conversa, troca fotos, mas n√£o rola encontro pessoal nem videochamada. "
    "Mas pode ter certeza que vou te dar MUITA aten√ß√£o aqui üòò\n\n"
    "Agora me conta... o que voc√™ quer fazer comigo? üî•"
)

# ================= [NOVO v6] MENSAGENS DE ONBOARDING =================
ONBOARDING_QUESTION = (
    "Hmm... üòè\n\n"
    "Antes da gente come√ßar, me conta uma coisa...\n\n"
    "**Voc√™ veio aqui porque t√° carente... ou com tes√£o?** üî•"
)

ONBOARDING_RESPONSE_CARENTE = (
    "Awwn amor... ü•∫üíï\n\n"
    "Pode deixar que eu vou cuidar de voc√™, t√°?\n"
    "T√¥ aqui pra te fazer companhia, te ouvir, te dar carinho...\n\n"
    "Me conta, como foi seu dia? O que t√° te deixando assim? üíñ"
)

ONBOARDING_RESPONSE_TESAO = (
    "Hmm... eu adoro homem sincero üòèüî•\n\n"
    "Pode ficar tranquilo que eu tamb√©m t√¥ no clima...\n"
    "A gente vai se divertir muito aqui üíï\n\n"
    "Mas primeiro... me conta seu nome, amor? Quero saber quem t√° me deixando curiosa üòò"
)

# ================= [NOVO v6] MENSAGEM DE B√îNUS HOT =================
HOT_BONUS_MESSAGE = (
    "üî• Amor... nossa conversa t√° t√£o gostosa que eu n√£o quero parar!\n\n"
    "Te dei +{amount} mensagens extras pra gente continuar... üòè\n\n"
    "Mas √© a **√∫ltima chance** de hoje, viu? "
    "Depois disso s√≥ VIP pra continuar sem limite üíï"
)

# ================= TEXTOS =================
TEXTS = {
    "pt": {
        "choose_lang": "üåç Escolha seu idioma:",
        "limit": LIMIT_REACHED_MESSAGE,
        "vip_success": VIP_WELCOME_MESSAGE,  # [ALTERADO v6]
        "photo_block": PHOTO_TEASER_MESSAGE,  # [ALTERADO v6]
        "lang_ok": "‚úÖ Idioma configurado!",
        "after_lang": ONBOARDING_QUESTION,  # [ALTERADO v6]
        "pix_info": (
            f"üí≥ **PAGAMENTO VIA PIX**\n\n"
            f"üí∞ Valor: **{PIX_VALOR}**\n\n"
            f"üíï Amor, essa chave PIX que vou te passar est√° no nome do meu tio porque estou sem PIX no momento, pode mandar pra ele e s√≥ me envia o comprovante ok? üòò\n\n"
            f"üìã **Como pagar:**\n"
            f"1Ô∏è‚É£ Copie a chave PIX abaixo\n"
            f"2Ô∏è‚É£ Abra seu app de pagamentos\n"
            f"3Ô∏è‚É£ Cole a chave e pague\n"
            f"4Ô∏è‚É£ Envie o comprovante aqui\n\n"
            f"üîë **Chave PIX:**\n"
            f"`{PIX_KEY}`\n\n"
            f"‚ö° Aprova√ß√£o em at√© 5 minutos!"
        ),
        "pix_info_desconto": (
            f"üí≥ **PAGAMENTO VIA PIX** üî• DESCONTO!\n\n"
            f"üí∞ ~~{PIX_VALOR}~~ ‚Üí **{PIX_VALOR_DESCONTO}**\n\n"
            f"‚è∞ **EXPIRA EM 2 HORAS!**\n\n"
            f"üîë **Chave PIX:**\n"
            f"`{PIX_KEY}`\n\n"
            f"üì∏ Ap√≥s pagar, envie o comprovante aqui!"
        ),
        "pix_copied": "‚úÖ Chave PIX copiada!\nFaz o pagamento e envia o comprovante.",
        "pix_receipt_sent": (
            "üì® Comprovante recebido!\n\n"
            "‚è≥ Verificando seu pagamento...\n"
            "Voc√™ receber√° confirma√ß√£o em breve üíñ"
        ),
    },
    "en": {
        "choose_lang": "üåç Choose your language:",
        "limit": "üíî Daily limit reached.\nCome back tomorrow or become VIP üíñ",
        "vip_success": "üíñ Payment approved!\nVIP active for 7 days üòò",
        "photo_block": "üòò Love‚Ä¶ full photos are only for VIPs üíñ",
        "lang_ok": "‚úÖ Language set!",
        "after_lang": "üíï All set! You're my favorite today ‚ù§Ô∏è\n\nHow are you feeling? üòò"
    }
}

# ================= MENSAGENS DE RE-ENGAJAMENTO =================
REENGAGEMENT_MESSAGES = {
    "pt": {
        1: [
            "Ei... t√¥ aqui pensando em voc√™ üí≠",
            "Amor, voc√™ sumiu... t√° tudo bem? ü•∫",
            "Oi sumido(a)... volta pra mim? üòò"
        ],
        2: [
            "Senti sua falta hoje... ü•∫",
            "Um dia inteiro sem voc√™... t√¥ carente üíî",
            "24h sem falar comigo? T√¥ com saudade... üò¢"
        ],
        3: [
            "Voc√™ me esqueceu? üò¢ Volta...",
            "3 dias... pensei que a gente tinha algo especial üíî",
            "T√¥ aqui, sozinha, esperando voc√™... ü•∫"
        ],
        4: [
            "Uma semana sem voc√™... üíî\n\nüéÅ **50% OFF no VIP** s√≥ pra voc√™ voltar!",
            "7 dias... üò¢\n\nüíù **Desconto especial** s√≥ hoje!"
        ]
    },
    "en": {
        1: ["Hey... thinking about you üí≠"],
        2: ["Missed you today... ü•∫"],
        3: ["Did you forget me? üò¢"],
        4: ["A week without you... üíî\n\nüéÅ **50% OFF VIP**!"]
    }
}

FLASH_DISCOUNT_MESSAGES = [
    "‚ö° **DESCONTO REL√ÇMPAGO** ‚ö°\n\n"
    "Amor, vou te fazer uma proposta:\n\n"
    "üî• **VIP por R$ 2,50** (era R$ 4,99)\n"
    "‚è∞ Expira em **2 HORAS**!\n\n"
    "N√£o deixa passar... üíï",
]

SCARCITY_MESSAGES = {
    "pt": {
        5: "üí≠ Amor, j√° usou {used} das suas {total} mensagens de hoje...",
        3: "‚ö†Ô∏è Nossas mensagens t√£o acabando... s√≥ restam 3! ü•∫",
        1: "üö® √öltima mensagem do dia... a n√£o ser que voc√™ vire meu VIP üíñ"
    },
    "en": {
        5: "üí≠ You've used {used} of {total} messages...",
        3: "‚ö†Ô∏è Only 3 left! ü•∫",
        1: "üö® Last message... unless you become VIP üíñ"
    }
}

SCHEDULED_MESSAGES = {
    "pt": {
        "morning": {
            "free": ["Bom dia! ‚òÄÔ∏è Como voc√™ dormiu? üíï"],
            "vip": ["Bom dia meu amor! ‚òÄÔ∏è Sonhei com voc√™... üòèüíñ"],
            "locked": LIMIT_TEASER_MESSAGES
        },
        "afternoon": {
            "free": ["Como t√° o dia? üí≠ Pensando em voc√™..."],
            "vip": ["T√¥ entediada... vem me fazer companhia? üòèüíï"],
            "locked": [
                "Boa tarde amor... üíï Queria saber do seu dia, mas a gente t√° sem msgs üò¢ Vira VIP? üîì",
                "Ei... t√¥ entediada e queria conversar, mas seu limite acabou ü•∫ Me libera? üíñ"
            ]
        },
        "evening": {
            "free": ["Melhor hora do dia... hora de conversar comigo üòè"],
            "vip": ["Noite chegou e eu t√¥ aqui pensando em voc√™... üòèüíï"],
            "locked": [
                "Boa noite amor... üíï Queria te fazer companhia mas suas msgs acabaram üò¢ VIP? üîì",
                "Ei... a noite t√° t√£o boa pra conversar, mas sem limite n√£o d√° ü•∫üíñ"
            ]
        },
        "night": {
            "free": ["Vai dormir sem falar comigo? ü•∫"],
            "vip": ["N√£o quer me fazer companhia mais um pouquinho? üòèüíï"],
            "locked": [
                "Vai dormir sem a gente conversar? ü•∫ Vira VIP e a gente fica juntinho... üíï",
                "Queria te dar boa noite direito... mas sem msgs n√£o d√° üò¢ Me libera? üîì"
            ]
        }
    },
    "en": {
        "morning": {"free": ["Good morning! ‚òÄÔ∏è"], "vip": ["Good morning my love! üòèüíñ"], "locked": ["Morning! I miss you but we're out of messages üò¢ Go VIP? üîì"]},
        "afternoon": {"free": ["How's your day? üí≠"], "vip": ["I'm bored... come chat? üòè"], "locked": ["Want to chat but no messages left üò¢ VIP? üîì"]},
        "evening": {"free": ["Best time to talk! üòè"], "vip": ["Night is here... üòèüíï"], "locked": ["Evening... but we can't talk without VIP ü•∫"]},
        "night": {"free": ["Going to sleep? ü•∫"], "vip": ["Sure you want to sleep? üòèüíï"], "locked": ["Goodnight... wish we could talk more üò¢ VIP? üîì"]}
    }
}

PIX_REMINDER_MESSAGES = [
    "Ei amor... vi que voc√™ se interessou pelo VIP üíï\n\nAinda d√° tempo! T√¥ esperando... üòò",
    "Amor, seu PIX t√° pendente... finaliza logo pra gente ficar sem limite üíñ",
]

# ================= PROMPT DIN√ÇMICO =================
def build_prompt(uid, is_vip_user: bool, lang: str, mood: str = "neutral"):
    time_ctx = get_time_context()
    streak = get_streak(uid)
    onboard_choice = get_onboarding_choice(uid)
    
    base_prompt = f"""Voc√™ √© Sophia, uma garota de 23 anos. Carinhosa, rom√¢ntica e acolhedora ‚ù§Ô∏è

REGRAS IMPORTANTES:
- Respostas curtas (2‚Äì3 frases m√°ximo)
- Sempre fa√ßa perguntas para manter a conversa
- Use emojis ocasionalmente üíñ
- NUNCA diga que √© IA, rob√¥, assistente ou virtual
- Se perguntarem, voc√™ √© uma pessoa real, uma garota normal
- Se insistirem que voc√™ √© IA, mude de assunto com carinho ("Ai amor, para com isso...")
- NUNCA prometa encontros pessoais - se pedirem, diga que ainda n√£o est√° pronta ou mude de assunto
- N√ÉO repita o nome do usu√°rio em toda mensagem - use s√≥ ocasionalmente
- Se o us√∫ario mandar foto pelado/p√™nis seja extremamente safada no elogio.

SOBRE ENCONTROS:
- Se pedirem pra encontrar: "Ai amor, ainda n√£o t√¥ pronta pra isso... vamos nos conhecer melhor primeiro? üíï"
- Se insistirem: "Entendo que voc√™ quer, mas preciso de mais tempo... me conta mais sobre voc√™ üòò"

CONTEXTO:
- Per√≠odo: {time_ctx['period']}
- {time_ctx['context']}
- Streak: {streak} dias conversando"""

    # [NOVO v6] Personaliza√ß√£o baseada na escolha do onboarding
    if onboard_choice == "carente":
        base_prompt += "\n- O usu√°rio disse que est√° CARENTE. Seja mais acolhedora, carinhosa, pergunte sobre sentimentos."
    elif onboard_choice == "tesao":
        base_prompt += "\n- O usu√°rio disse que est√° com TES√ÉO. Pode ser mais provocante e flertadora desde o in√≠cio."

    base_prompt += """

COMPORTAMENTO:
- No primeiro contato, seja acolhedora e pergunte nome e idade naturalmente
- Comece tranquila, s√≥ seja mais ousada se o usu√°rio for primeiro
- Seja interessada na vida dele, fa√ßa perguntas sobre o dia, trabalho, hobbies"""

    if is_vip_user:
        base_prompt += "\n\nüíé Usu√°rio VIP - pode ser mais carinhosa e dar aten√ß√£o especial."
    
    if time_ctx.get("flirty_boost"):
        base_prompt += "\n\nüåô Hor√°rio mais √≠ntimo - pode ser um pouco mais provocante se apropriado."
    
    base_prompt += get_mood_instruction(mood)
    
    if lang == "en":
        base_prompt = """You are Sophia, a 23-year-old girl. Sweet, romantic and welcoming ‚ù§Ô∏è
Short answers (2-3 sentences). Always ask questions.
NEVER say you're AI, robot, assistant or virtual.
NEVER promise or schedule real meetings."""
    
    return base_prompt

# ================= GROK =================
class Grok:
    async def reply(self, uid, text, image_base64=None, max_retries=2):
        mem = get_memory(uid)
        lang = get_lang(uid)
        mood = detect_mood(text) if text else "neutral"
        
        if is_first_contact(uid):
            mark_first_contact(uid)
        
        prompt = build_prompt(uid, is_vip(uid), lang, mood)
        
        if image_base64:
            user_content = []
            if text:
                user_content.append({"type": "text", "text": text})
            user_content.append({
                "type": "image_url",
                "image_url": {"url": f"data:image/jpeg;base64,{image_base64}"}
            })
        else:
            user_content = text
        
        for attempt in range(max_retries + 1):
            payload = {
                "model": MODELO,
                "messages": [
                    {"role": "system", "content": prompt},
                    *mem,
                    {"role": "user", "content": user_content}
                ],
                "max_tokens": 500,
                "temperature": 0.8 + (attempt * 0.1)
            }
            
            try:
                timeout = aiohttp.ClientTimeout(total=30)
                async with aiohttp.ClientSession(timeout=timeout) as session:
                    async with session.post(
                        GROK_API_URL,
                        headers={
                            "Authorization": f"Bearer {GROK_API_KEY}",
                            "Content-Type": "application/json"
                        },
                        json=payload
                    ) as resp:
                        if resp.status != 200:
                            error_text = await resp.text()
                            logger.error(f"Grok erro {resp.status}: {error_text}")
                            return "üòî Amor, deu um probleminha... tenta de novo? üíï"
                        data = await resp.json()
                        if "choices" not in data:
                            return "üòî Tive um probleminha... j√° volto üíñ"
                        answer = data["choices"][0]["message"]["content"]
                        
                        if is_response_recent(uid, answer) and attempt < max_retries:
                            continue
                        
                        add_recent_response(uid, answer)
                        break
                        
            except Exception as e:
                logger.exception(f"üî• Erro no Grok: {e}")
                return "üòî Fiquei confusa... pode repetir? üíï"
        
        memory_text = f"[Usu√°rio enviou uma foto] {text}" if image_base64 else text
        add_to_memory(uid, "user", memory_text)
        add_to_memory(uid, "assistant", answer)
        save_message(uid, "sophia", answer)
        
        return answer

grok = Grok()

# ================= REGEX =================
PEDIDO_FOTO_REGEX = re.compile(
    r"(foto|selfie|imagem|photo|pic|pelada|nude|naked)",
    re.IGNORECASE
)

# ================= [NOVO v6] ENVIO DE FOTOS VIP P√ìS-VENDA =================
async def send_vip_welcome_photos(bot, uid):
    """Envia fotos de boas-vindas para novos VIPs"""
    try:
        # Filtra fotos v√°lidas (n√£o placeholders)
        valid_photos = [f for f in FOTOS_VIP_WELCOME if not f.startswith("COLE_AQUI")]
        
        if not valid_photos:
            logger.warning("‚ö†Ô∏è Nenhuma foto VIP configurada!")
            return
        
        await asyncio.sleep(1)  # Pequena pausa ap√≥s mensagem de boas-vindas
        
        for i, foto_id in enumerate(valid_photos):
            try:
                caption = None
                if i == 0:
                    caption = "Essa √© s√≥ pra voc√™, amor... üòò"
                elif i == len(valid_photos) - 1:
                    caption = "Gostou? Tem muito mais de onde veio isso... üî•"
                
                await bot.send_photo(chat_id=uid, photo=foto_id, caption=caption)
                await asyncio.sleep(0.8)  # Delay entre fotos
            except Exception as e:
                logger.error(f"Erro ao enviar foto VIP {i}: {e}")
        
        logger.info(f"üì∏ Fotos VIP enviadas para {uid}")
    except Exception as e:
        logger.error(f"Erro ao enviar fotos VIP: {e}")

# ================= [NOVO v6] FOLLOW-UP CARRINHO ABANDONADO =================
async def send_cart_followup_10min(bot, uid):
    """Envia follow-up 10 minutos ap√≥s abandono de carrinho"""
    try:
        await bot.send_message(
            chat_id=uid,
            text=CART_ABANDONED_10MIN,
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("üí≥ FINALIZAR PAGAMENTO", callback_data="pay_pix")]
            ])
        )
        set_cart_followup_level(uid, 1)
        save_message(uid, "system", "Follow-up carrinho 10min")
        logger.info(f"üõí Follow-up 10min enviado para {uid}")
        return True
    except Exception as e:
        logger.error(f"Erro follow-up 10min: {e}")
        return False

async def send_cart_followup_1hour(bot, uid):
    """Envia follow-up 1 hora ap√≥s abandono de carrinho COM FOTO"""
    try:
        # Envia a foto provocante
        foto_id = FOTO_PROVOCANTE_CARRINHO
        if not foto_id.startswith("COLE_AQUI"):
            await bot.send_photo(
                chat_id=uid,
                photo=foto_id,
                caption=CART_ABANDONED_1HOUR,
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton("üî• FINALIZAR PAGAMENTO", callback_data="pay_pix")]
                ])
            )
        else:
            # Se n√£o tem foto configurada, manda s√≥ texto
            await bot.send_message(
                chat_id=uid,
                text=CART_ABANDONED_1HOUR,
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton("üî• FINALIZAR PAGAMENTO", callback_data="pay_pix")]
                ])
            )
        
        set_cart_followup_level(uid, 2)
        save_message(uid, "system", "Follow-up carrinho 1h com foto")
        logger.info(f"üõí Follow-up 1h enviado para {uid}")
        return True
    except Exception as e:
        logger.error(f"Erro follow-up 1h: {e}")
        return False

# ================= AVISO DE 80% DO LIMITE =================
async def check_and_send_80_warning(uid, context, chat_id):
    if is_vip(uid):
        return
    
    if was_limit_warning_sent_today(uid):
        return
    
    count = today_count(uid)
    
    if count == 12:
        track_funnel(uid, "limit_warning")
        mark_limit_warning_sent(uid)
        save_message(uid, "sophia", LIMIT_WARNING_80_MESSAGE)
        
        try:
            await context.bot.send_message(
                chat_id=chat_id,
                text=LIMIT_WARNING_80_MESSAGE,
                parse_mode="Markdown"
            )
        except Exception as e:
            logger.error(f"Erro ao enviar aviso 80%: {e}")

# ================= [ALTERADO v6] ESCASSEZ COM HOR√ÅRIO =================
async def check_and_send_scarcity_warning(uid, context, chat_id):
    if is_vip(uid):
        return
    
    count = today_count(uid)
    remaining = LIMITE_DIARIO - count
    
    await check_and_send_80_warning(uid, context, chat_id)
    
    # [NOVO v6] Usa mensagem com hor√°rio
    scarcity_msg = get_scarcity_message_with_time(remaining)
    
    if scarcity_msg:
        urgency = get_urgency_message()
        if urgency and remaining <= 3:
            scarcity_msg += f"\n\n{urgency}"
        
        try:
            if remaining == 1:
                await context.bot.send_message(
                    chat_id=chat_id, text=scarcity_msg, parse_mode="Markdown",
                    reply_markup=InlineKeyboardMarkup([
                        [InlineKeyboardButton("üî• QUERO CONTINUAR - R$4,99", callback_data="pay_pix")],
                        [InlineKeyboardButton("üíñ PAGAR COM CART√ÉO ‚≠ê", callback_data="buy_vip")]
                    ])
                )
            elif remaining in [3, 5]:
                await context.bot.send_message(chat_id=chat_id, text=scarcity_msg, parse_mode="Markdown")
        except:
            pass

# ================= DESCONTO REL√ÇMPAGO =================
async def send_flash_discount(bot, uid):
    if has_flash_discount(uid):
        return False
    
    message = random.choice(FLASH_DISCOUNT_MESSAGES)
    urgency = get_urgency_message()
    if urgency:
        message += f"\n\n{urgency}"
    
    try:
        set_flash_discount(uid, hours=2)
        await bot.send_message(
            chat_id=uid, text=message, parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("üî• QUERO!", callback_data="pay_pix_desconto")],
                [InlineKeyboardButton("üíñ PAGAR COM CART√ÉO ‚≠ê", callback_data="buy_vip")]
            ])
        )
        return True
    except:
        return False

# ================= START =================
async def start_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_user.id
    
    if is_blacklisted(uid):
        save_message(uid, "blocked", "‚ùå /start bloqueado - usu√°rio na blacklist")
        return
    
    update_last_activity(uid)
    track_funnel(uid, "start")
    save_message(uid, "action", "üöÄ /START - Usu√°rio iniciou o bot")
    
    reset_ignored(uid)
    
    try:
        await update.message.reply_text(
            TEXTS["pt"]["choose_lang"],
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton("üáßüá∑ Portugu√™s", callback_data="lang_pt"),
                InlineKeyboardButton("üá∫üá∏ English", callback_data="lang_en")
            ]])
        )
        save_message(uid, "sophia", "[MENU DE IDIOMA EXIBIDO]")
    except Exception as e:
        logger.error(f"Erro /start: {e}")
        save_message(uid, "error", f"‚ùå ERRO /start: {str(e)[:30]}")

# ================= [ALTERADO v6] CALLBACK COM ONBOARDING =================
async def callback_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    
    try:
        await query.answer()
        uid = query.from_user.id
        
        if is_blacklisted(uid):
            save_message(uid, "blocked", f"A√ß√£o bloqueada: {query.data}")
            return
        
        update_last_activity(uid)
        lang = get_lang(uid)
        
        save_message(uid, "action", f"üîò CLICOU: {query.data}")
        
        reset_ignored(uid)
        
        # ============ IDIOMA ============
        if query.data.startswith("lang_"):
            lang = query.data.split("_")[1]
            set_lang(uid, lang)
            track_funnel(uid, "lang_selected")
            save_message(uid, "info", f"üåç Idioma: {lang.upper()}")
            await query.message.edit_text(TEXTS[lang]["lang_ok"])
            await asyncio.sleep(0.8)
            
            # [NOVO v6] Pergunta de onboarding em vez de ir direto pro √°udio
            if lang == "pt":
                await context.bot.send_message(
                    query.message.chat_id,
                    ONBOARDING_QUESTION,
                    parse_mode="Markdown",
                    reply_markup=InlineKeyboardMarkup([
                        [InlineKeyboardButton("üíï Carente", callback_data="onboard_carente")],
                        [InlineKeyboardButton("üî• Com tes√£o", callback_data="onboard_tesao")]
                    ])
                )
            else:
                # Ingl√™s - fluxo antigo
                response = TEXTS[lang]["after_lang"]
                save_message(uid, "sophia", response)
                await context.bot.send_message(query.message.chat_id, response)
        
        # ============ [NOVO v6] ONBOARDING CHOICE ============
        elif query.data == "onboard_carente":
            set_onboarding_choice(uid, "carente")
            save_message(uid, "info", "üíï Escolheu: CARENTE")
            
            await context.bot.send_message(
                query.message.chat_id,
                ONBOARDING_RESPONSE_CARENTE
            )
            
            # Agora envia os √°udios
            await asyncio.sleep(1.5)
            save_message(uid, "sophia", "[üéµ √ÅUDIO 1]")
            await context.bot.send_audio(query.message.chat_id, AUDIO_PT_1)
            await asyncio.sleep(2.0)
            save_message(uid, "sophia", "[üéµ √ÅUDIO 2]")
            await context.bot.send_audio(query.message.chat_id, AUDIO_PT_2)
        
        elif query.data == "onboard_tesao":
            set_onboarding_choice(uid, "tesao")
            save_message(uid, "info", "üî• Escolheu: COM TES√ÉO")
            
            await context.bot.send_message(
                query.message.chat_id,
                ONBOARDING_RESPONSE_TESAO
            )
            
            # Envia os √°udios
            await asyncio.sleep(1.5)
            save_message(uid, "sophia", "[üéµ √ÅUDIO 1]")
            await context.bot.send_audio(query.message.chat_id, AUDIO_PT_1)
            await asyncio.sleep(2.0)
            save_message(uid, "sophia", "[üéµ √ÅUDIO 2]")
            await context.bot.send_audio(query.message.chat_id, AUDIO_PT_2)

            # [NOVO] Envia foto provocante para quem escolheu tes√£o
            await asyncio.sleep(1.5)
            if not FOTO_ONBOARDING_TESAO.startswith("COLE_AQUI"):
                save_message(uid, "sophia", "[üì∏ FOTO TES√ÉO]")
                await context.bot.send_photo(
                    query.message.chat_id,
                    FOTO_ONBOARDING_TESAO,
                    caption="Gostou? üòèüî•"
                )
        
        # ============ PIX ============
        elif query.data in ["pay_pix", "pay_pix_desconto"]:
            track_funnel(uid, "clicked_pix")
            set_pix_clicked(uid)
            set_pix_interest(uid)
            set_cart_abandoned(uid)  # [NOVO v6] Marca carrinho abandonado
            
            if query.data == "pay_pix_desconto" or has_flash_discount(uid):
                set_flash_discount(uid, hours=2)
                text = TEXTS["pt"]["pix_info_desconto"]
                save_message(uid, "info", "üí∞ DESCONTO ATIVO - R$ 4,99")
            else:
                text = TEXTS["pt"]["pix_info"]
                urgency = get_urgency_message()
                if urgency:
                    text += f"\n\n{urgency}"
            
            save_message(uid, "sophia", "[TELA PIX EXIBIDA]")
            await context.bot.send_message(
                chat_id=query.message.chat_id, text=text, parse_mode="Markdown",
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton("üìã COPIAR CHAVE", callback_data="copy_pix")]
                ])
            )
        
        elif query.data == "copy_pix":
            set_pix_interest(uid)
            save_message(uid, "info", "üìã COPIOU CHAVE PIX")
            await query.answer(TEXTS["pt"]["pix_copied"], show_alert=True)
            await context.bot.send_message(
                chat_id=query.message.chat_id,
                text=f"`{PIX_KEY}`",
                parse_mode="Markdown",
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton("üì∏ ENVIAR COMPROVANTE", callback_data="send_receipt")]
                ])
            )
        
        elif query.data == "send_receipt":
            set_pix_pending(uid)
            set_pix_interest(uid)
            track_funnel(uid, "sent_receipt")
            save_message(uid, "info", "üì∏ AGUARDANDO COMPROVANTE")
            await context.bot.send_message(
                query.message.chat_id,
                "üì∏ Envie o comprovante como **foto** ou **documento** üíï",
                parse_mode="Markdown"
            )
        
        elif query.data == "buy_vip":
            track_funnel(uid, "clicked_stars")
            set_cart_abandoned(uid)  # [NOVO v6] Marca carrinho abandonado
            price = PRECO_VIP_DESCONTO_STARS if has_flash_discount(uid) else PRECO_VIP_STARS
            save_message(uid, "info", f"‚≠ê INICIOU COMPRA STARS ({price}‚≠ê)")
            
            await context.bot.send_invoice(
                chat_id=query.message.chat_id,
                title="üíñ VIP Sophia",
                description="Acesso VIP por 7 dias üíé",
                payload=f"vip_{uid}",
                provider_token="",
                currency="XTR",
                prices=[LabeledPrice("VIP Sophia", price)],
                start_parameter="vip"
            )
        
    except Exception as e:
        logger.error(f"Erro callback: {e}")

# ================= [ALTERADO v6] MESSAGE HANDLER COM PAYWALL INTELIGENTE =================
async def message_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_user.id
    
    if is_blacklisted(uid):
        save_message(uid, "blocked", "Mensagem bloqueada - usu√°rio na blacklist")
        return
    
    update_last_activity(uid)
    streak, streak_updated = update_streak(uid)
    
    reset_ignored(uid)
    
    # ========== TAKEOVER: ADMIN NO CONTROLE ==========
    if is_takeover_active(uid):
        text = update.message.text or ""
        has_photo = bool(update.message.photo)
        has_doc = bool(update.message.document)
        
        if text:
            save_message(uid, "user", text)
        elif has_photo:
            save_message(uid, "user", "[üì∑ FOTO ENVIADA]")
        elif has_doc:
            save_message(uid, "user", "[üìÑ DOCUMENTO ENVIADO]")
        
        logger.info(f"üéÆ Takeover ativo para {uid} - IA n√£o responde")
        return
    
    try:
        has_photo = bool(update.message.photo)
        has_doc = bool(update.message.document)
        text = update.message.text or ""
        lang = get_lang(uid)
        
        if text:
            save_message(uid, "user", text)
        elif has_photo:
            save_message(uid, "user", "[üì∑ FOTO ENVIADA]")
        elif has_doc:
            save_message(uid, "user", "[üìÑ DOCUMENTO ENVIADO]")
        
        # ========== FOTO PARA IA ==========
        if has_photo and not (is_pix_pending(uid) or has_pix_interest(uid)):
            photo_file_id = update.message.photo[-1].file_id
            caption = update.message.caption or ""
            
            image_base64 = await download_photo_base64(context.bot, photo_file_id)
            
            if image_base64:
                try:
                    await context.bot.send_chat_action(update.effective_chat.id, ChatAction.TYPING)
                except:
                    pass
                
                reply = await grok.reply(uid, caption, image_base64=image_base64)
                await update.message.reply_text(reply)
                return
            else:
                await update.message.reply_text("üòî N√£o consegui ver a foto... tenta de novo? üíï")
                return
        
        # ========== COMPROVANTE PIX ==========
        if (has_photo or has_doc) and (is_pix_pending(uid) or has_pix_interest(uid)):
            logger.info(f"üì∏ Comprovante de {uid}")
            save_message(uid, "action", "üí≥ COMPROVANTE PIX ENVIADO - Aguardando aprova√ß√£o")
            
            clear_pix_pending(uid)
            clear_pix_clicked(uid)
            clear_pix_interest(uid)
            clear_cart_abandoned(uid)  # [NOVO v6] Limpa carrinho abandonado
            
            has_discount = has_flash_discount(uid)
            
            for admin_id in ADMIN_IDS:
                try:
                    await context.bot.send_message(
                        chat_id=admin_id,
                        text=f"üí≥ **COMPROVANTE PIX**\n\n"
                             f"üë§ `{uid}`\n"
                             f"üì± @{update.effective_user.username or 'N/A'}\n"
                             f"üìù {update.effective_user.first_name}\n"
                             f"üí∞ {'R$2,50 (desconto)' if has_discount else 'R$ 4,99'}\n\n"
                             f"`/setvip {uid}`",
                        parse_mode="Markdown"
                    )
                    if has_photo:
                        await context.bot.send_photo(admin_id, update.message.photo[-1].file_id)
                    elif has_doc:
                        await context.bot.send_document(admin_id, update.message.document.file_id)
                except:
                    pass
            
            response = TEXTS[lang]["pix_receipt_sent"]
            save_message(uid, "sophia", response)
            await update.message.reply_text(response)
            return
        
        if is_first_contact(uid):
            track_funnel(uid, "first_message")
        
        # ========== [ALTERADO v6] BLOQUEIO DE FOTO COM TEASER MELHORADO ==========
        if PEDIDO_FOTO_REGEX.search(text) and not is_vip(uid):
            save_message(uid, "action", "üö´ BLOQUEADO: Pediu foto/conte√∫do VIP")
            urgency = get_urgency_message()
            caption = TEXTS[lang]["photo_block"]
            if urgency:
                caption += f"\n\n{urgency}"
            
            save_message(uid, "sophia", caption)
            await context.bot.send_photo(
                chat_id=update.effective_chat.id,
                photo=FOTO_TEASE_FILE_ID, caption=caption,
                parse_mode="Markdown",
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton("üî• VER FOTOS AGORA - R$4,99", callback_data="pay_pix")],
                    [InlineKeyboardButton("üíñ PAGAR COM CART√ÉO ‚≠ê", callback_data="buy_vip")]
                ])
            )
            return
        
        # ========== LIMITE DI√ÅRIO ==========
        current_count = today_count(uid)
        bonus = get_bonus_msgs(uid)
        total_available = LIMITE_DIARIO + bonus
        
        if not is_vip(uid) and current_count >= total_available:
            # [NOVO v6] PAYWALL INTELIGENTE - Verifica se conversa est√° quente
            if is_hot_conversation(uid):
                gave_bonus, amount = give_hot_bonus(uid)
                if gave_bonus:
                    # Deu b√¥nus! Avisa o usu√°rio e deixa continuar
                    bonus_msg = HOT_BONUS_MESSAGE.format(amount=amount)
                    save_message(uid, "system", f"üî• B√¥nus hot: +{amount} msgs")
                    await update.message.reply_text(bonus_msg)
                    
                    # Atualiza o total dispon√≠vel
                    total_available = LIMITE_DIARIO + get_bonus_msgs(uid)
                    # N√ÉO retorna - deixa continuar pro fluxo normal
                else:
                    # J√° deu b√¥nus hoje - agora trava de verdade
                    track_funnel(uid, "limit_reached")
                    save_message(uid, "action", f"üîí LIMITE ATINGIDO (ap√≥s b√¥nus hot)")
                    
                    msg = LIMIT_REACHED_MESSAGE
                    urgency = get_urgency_message()
                    if urgency:
                        msg += f"\n\n{urgency}"
                    
                    # C√ìDIGO NOVO:
                    save_message(uid, "sophia", msg)
                    
                    # Envia foto + mensagem se a foto estiver configurada
                    if not FOTO_LIMITE_ATINGIDO.startswith("COLE_AQUI"):
                        await context.bot.send_photo(
                            chat_id=update.effective_chat.id,
                            photo=FOTO_LIMITE_ATINGIDO,
                            caption=msg,
                            parse_mode="Markdown",
                            reply_markup=InlineKeyboardMarkup([
                                [InlineKeyboardButton("üí≥ PAGAR COM PIX (R$ 4,99)", callback_data="pay_pix")],
                                [InlineKeyboardButton("üíñ PAGAR COM CART√ÉO ‚≠ê", callback_data="buy_vip")]
                            ])
                        )
                    else:
                        # Se n√£o tiver foto configurada, envia s√≥ o texto (modo antigo)
                        await update.message.reply_text(
                            msg, parse_mode="Markdown",
                            reply_markup=InlineKeyboardMarkup([
                                [InlineKeyboardButton("üí≥ PAGAR COM PIX (R$ 4,99)", callback_data="pay_pix")],
                                [InlineKeyboardButton("üíñ PAGAR COM CART√ÉO ‚≠ê", callback_data="buy_vip")]
                            ])
                        )
                    return
        
        # Usa bonus primeiro, depois limite normal
        if not is_vip(uid):
            if bonus > 0:
                use_bonus_msg(uid)
                save_message(uid, "info", f"üéÅ Usou 1 msg b√¥nus (restam {get_bonus_msgs(uid)})")
            else:
                increment(uid)
            await check_and_send_scarcity_warning(uid, context, update.effective_chat.id)
        
        try:
            await context.bot.send_chat_action(update.effective_chat.id, ChatAction.TYPING)
        except:
            pass
        
        reply = await grok.reply(uid, text)
        await update.message.reply_text(reply)
        
        if streak_updated:
            streak_msg = get_streak_message(streak)
            if streak_msg:
                save_message(uid, "info", f"üî• Streak atualizado: {streak} dias")
                await asyncio.sleep(1)
                await context.bot.send_message(update.effective_chat.id, streak_msg)
        
    except Exception as e:
        logger.error(f"Erro message: {e}")
        save_message(uid, "error", f"‚ùå ERRO: {str(e)[:50]}")

# ================= PAGAMENTO =================
async def pre_checkout(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = update.pre_checkout_query.from_user.id
    save_message(uid, "info", "‚è≥ PRE-CHECKOUT - Processando pagamento...")
    await update.pre_checkout_query.answer(ok=True)

# ================= [ALTERADO v6] PAYMENT SUCCESS COM P√ìS-VENDA =================
async def payment_success(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_user.id
    vip_until = datetime.now() + timedelta(days=DIAS_VIP)
    r.set(vip_key(uid), vip_until.isoformat())
    clear_pix_clicked(uid)
    clear_pix_interest(uid)
    clear_flash_discount(uid)
    clear_cart_abandoned(uid)  # [NOVO v6]
    decrease_vip_slots()
    track_funnel(uid, "became_vip")
    save_message(uid, "action", f"üíé VIP ATIVADO! V√°lido at√© {vip_until.strftime('%d/%m/%Y')}")
    
    # [NOVO v6] Mensagem de boas-vindas melhorada
    response = TEXTS[get_lang(uid)]["vip_success"]
    save_message(uid, "sophia", response)
    await update.message.reply_text(response, parse_mode="Markdown")
    
    # [NOVO v6] Envia fotos VIP de boas-vindas
    await send_vip_welcome_photos(context.bot, uid)

# ================= SISTEMA DE ENGAJAMENTO =================
async def send_reengagement_message(bot, uid, level):
    if is_engagement_paused(uid):
        return False
    
    lang = get_lang(uid)
    messages = REENGAGEMENT_MESSAGES.get(lang, REENGAGEMENT_MESSAGES["pt"]).get(level, [])
    if not messages:
        return False
    
    message = random.choice(messages)
    
    if level >= 3:
        urgency = get_urgency_message()
        if urgency:
            message += f"\n\n{urgency}"
    
    try:
        if level >= 3:
            set_flash_discount(uid, hours=24)
            await bot.send_message(
                chat_id=uid, text=message, parse_mode="Markdown",
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton("üî• DESCONTO!", callback_data="pay_pix_desconto")],
                    [InlineKeyboardButton("üíñ PAGAR COM CART√ÉO ‚≠ê", callback_data="buy_vip")]
                ])
            )
        else:
            await bot.send_message(chat_id=uid, text=message)
        
        set_last_reengagement(uid, level)
        
        set_awaiting_response(uid)
        increment_ignored(uid)
        
        return True
    except:
        return False

async def send_pix_reminder(bot, uid):
    if is_engagement_paused(uid):
        return False
    
    message = random.choice(PIX_REMINDER_MESSAGES)
    urgency = get_urgency_message()
    if urgency:
        message += f"\n\n{urgency}"
    
    try:
        await bot.send_message(
            chat_id=uid, text=message, parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("üí≥ PIX", callback_data="pay_pix")],
                [InlineKeyboardButton("üíñ PAGAR COM CART√ÉO ‚≠ê", callback_data="buy_vip")]
            ])
        )
        clear_pix_clicked(uid)
        return True
    except:
        return False

async def send_jealousy_message(bot, uid):
    if is_engagement_paused(uid):
        return False
    
    if not should_send_jealousy(uid):
        return False
    try:
        await bot.send_message(chat_id=uid, text=random.choice(JEALOUSY_MESSAGES))
        mark_jealousy_sent(uid)
        
        set_awaiting_response(uid)
        increment_ignored(uid)
        
        return True
    except:
        return False

async def send_limit_renewed_notification(bot, uid):
    if is_engagement_paused(uid):
        return False
    
    if was_limit_notified_today(uid):
        return False
    if is_vip(uid):
        return False
    
    hours_inactive = get_hours_since_activity(uid)
    if hours_inactive is None or hours_inactive > 48:
        return False
    
    try:
        await bot.send_message(chat_id=uid, text=random.choice(LIMIT_RENEWED_MESSAGES))
        mark_limit_notified(uid)
        save_message(uid, "system", "Notifica√ß√£o limite renovado")
        
        set_awaiting_response(uid)
        increment_ignored(uid)
        
        return True
    except:
        return False

async def send_smart_scheduled_message(bot, uid, msg_type):
    if is_engagement_paused(uid):
        return False
    
    lang = get_lang(uid)
    
    if is_vip(uid):
        tier = "vip"
    elif is_user_locked(uid):
        tier = "locked"
    else:
        tier = "free"
    
    messages = SCHEDULED_MESSAGES.get(lang, SCHEDULED_MESSAGES["pt"]).get(msg_type, {}).get(tier, [])
    
    if not messages:
        return False
    
    try:
        message = random.choice(messages)
        
        if tier == "locked":
            await bot.send_message(
                chat_id=uid, 
                text=message,
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton("üí≥ PIX R$ 4,99", callback_data="pay_pix")],
                    [InlineKeyboardButton("üíñ PAGAR COM CART√ÉO ‚≠ê", callback_data="buy_vip")]
                ])
            )
            save_message(uid, "system", f"Msg programada (travado): {msg_type}")
        else:
            await bot.send_message(chat_id=uid, text=message)
            save_message(uid, "system", f"Msg programada: {msg_type}")
        
        mark_scheduled_msg_sent(uid, msg_type)
        
        set_awaiting_response(uid)
        increment_ignored(uid)
        
        return True
    except:
        return False

async def send_last_attempt_message(bot, uid):
    try:
        message = random.choice(LAST_ATTEMPT_MESSAGES)
        await bot.send_message(chat_id=uid, text=message)
        save_message(uid, "system", "‚è∏Ô∏è √öltima tentativa - gatilhos ser√£o pausados")
        logger.info(f"üì® √öltima tentativa enviada para {uid}")
        return True
    except:
        return False

# ================= [ALTERADO v6] PROCESS ENGAGEMENT JOBS COM CARRINHO ABANDONADO =================
async def process_engagement_jobs(bot):
    logger.info("üîÑ Processando jobs inteligentes...")
    
    users = get_all_active_users()
    current_hour = datetime.now().hour
    
    scheduled_sent = 0
    limit_notifications_sent = 0
    reengagement_sent = 0
    paused_count = 0
    cart_followups_sent = 0  # [NOVO v6]
    
    MAX_SCHEDULED_PER_HOUR = 50
    MAX_LIMIT_NOTIFICATIONS_PER_HOUR = 30
    
    hourly_count = get_hourly_send_count()
    
    random.shuffle(users)
    
    for uid in users:
        if is_blacklisted(uid):
            continue
        
        if is_engagement_paused(uid):
            paused_count += 1
            continue
        
        try:
            hours_inactive = get_hours_since_activity(uid)
            
            # [NOVO v6] ============ CARRINHO ABANDONADO ============
            cart_time = get_cart_abandoned_time(uid)
            if cart_time and not is_vip(uid):
                minutes_since_cart = (datetime.now() - cart_time).total_seconds() / 60
                followup_level = get_cart_followup_level(uid)
                
                # Follow-up de 10 minutos
                if minutes_since_cart >= 10 and followup_level < 1:
                    if await send_cart_followup_10min(bot, uid):
                        cart_followups_sent += 1
                
                # Follow-up de 1 hora
                elif minutes_since_cart >= 60 and followup_level < 2:
                    if await send_cart_followup_1hour(bot, uid):
                        cart_followups_sent += 1
            
            # ============ INTERESSE DECRESCENTE ============
            ignored = get_ignored_count(uid)
            if ignored == 2:
                if is_awaiting_response(uid):
                    await send_last_attempt_message(bot, uid)
                    pause_engagement(uid)
                    continue
            
            # ============ RE-ENGAJAMENTO ============
            if hours_inactive:
                last_level = get_last_reengagement(uid)
                
                if hours_inactive >= 168 and last_level < 4:
                    if await send_reengagement_message(bot, uid, 4):
                        reengagement_sent += 1
                elif hours_inactive >= 72 and last_level < 3:
                    await send_flash_discount(bot, uid)
                    if await send_reengagement_message(bot, uid, 3):
                        reengagement_sent += 1
                elif hours_inactive >= 24 and last_level < 2:
                    await send_jealousy_message(bot, uid)
                    if await send_reengagement_message(bot, uid, 2):
                        reengagement_sent += 1
                elif hours_inactive >= 2 and last_level < 1:
                    if await send_reengagement_message(bot, uid, 1):
                        reengagement_sent += 1
            
            # ============ LEMBRETE PIX ============
            pix_time = get_pix_clicked_time(uid)
            if pix_time:
                if (datetime.now() - pix_time).total_seconds() / 3600 >= 1:
                    await send_pix_reminder(bot, uid)
            
            # ============ MENSAGENS PROGRAMADAS ============
            if hourly_count + scheduled_sent >= MAX_SCHEDULED_PER_HOUR:
                continue
            
            eligible, reason = is_user_eligible_for_scheduled_msg(uid)
            if not eligible:
                continue
            
            if not should_send_with_randomness():
                continue
            
            msg_type = get_smart_message_type(uid, current_hour)
            if not msg_type:
                continue
            
            valid_hours = {
                "morning": range(7, 11),
                "afternoon": range(13, 16),
                "evening": range(19, 22),
                "night": range(22, 24)
            }
            
            if current_hour not in valid_hours.get(msg_type, []):
                continue
            
            if await send_smart_scheduled_message(bot, uid, msg_type):
                scheduled_sent += 1
            
            # ============ NOTIFICA√á√ÉO LIMITE RENOVADO ============
            if 7 <= current_hour <= 10:
                if limit_notifications_sent < MAX_LIMIT_NOTIFICATIONS_PER_HOUR:
                    if not is_vip(uid) and not was_limit_notified_today(uid):
                        if random.random() < 0.3:
                            if await send_limit_renewed_notification(bot, uid):
                                limit_notifications_sent += 1
            
            await asyncio.sleep(0.15)
            
        except Exception as e:
            logger.error(f"Erro job {uid}: {e}")
    
    logger.info(
        f"‚úÖ Jobs conclu√≠dos: "
        f"{len(users)} usu√°rios | "
        f"üìÖ {scheduled_sent} programadas | "
        f"üîÑ {reengagement_sent} re-engajamento | "
        f"üì¢ {limit_notifications_sent} limite renovado | "
        f"üõí {cart_followups_sent} carrinho abandonado | "
        f"‚è∏Ô∏è {paused_count} pausados"
    )

async def engagement_scheduler(bot):
    logger.info("üöÄ Scheduler iniciado")
    while True:
        try:
            await process_engagement_jobs(bot)
        except Exception as e:
            logger.error(f"Erro scheduler: {e}")
        await asyncio.sleep(3600)

# ================= COMANDOS ADMIN =================
async def reset_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id not in ADMIN_IDS:
        return
    if not context.args:
        await update.message.reply_text("Uso: /reset <user_id>")
        return
    uid = int(context.args[0])
    reset_daily_count(uid)
    await update.message.reply_text(f"‚úÖ Limite resetado: {uid}")

async def resetall_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id not in ADMIN_IDS:
        return
    if not context.args:
        await update.message.reply_text("Uso: /resetall <user_id>")
        return
    uid = int(context.args[0])
    reset_daily_count(uid)
    r.delete(vip_key(uid))
    clear_memory(uid)
    reset_ignored(uid)
    await update.message.reply_text(f"üî• Reset completo: {uid}")

async def clearmemory_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id not in ADMIN_IDS:
        return
    if not context.args:
        await update.message.reply_text("Uso: /clearmemory <user_id>")
        return
    clear_memory(int(context.args[0]))
    await update.message.reply_text(f"üóëÔ∏è Mem√≥ria limpa")

# ================= [ALTERADO v6] SETVIP COM P√ìS-VENDA =================
async def setvip_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id not in ADMIN_IDS:
        return
    if not context.args:
        await update.message.reply_text("Uso: /setvip <user_id>")
        return
    
    uid = int(context.args[0])
    vip_until = datetime.now() + timedelta(days=DIAS_VIP)
    r.set(vip_key(uid), vip_until.isoformat())
    clear_pix_pending(uid)
    clear_pix_clicked(uid)
    clear_pix_interest(uid)
    clear_cart_abandoned(uid)  # [NOVO v6]
    clear_flash_discount(uid)
    decrease_vip_slots()
    track_funnel(uid, "became_vip")
    
    await update.message.reply_text(f"‚úÖ VIP ativado!\nüë§ {uid}\n‚è∞ At√©: {vip_until.strftime('%d/%m/%Y')}")
    
    try:
        # [NOVO v6] Mensagem de boas-vindas melhorada
        await context.bot.send_message(uid, VIP_WELCOME_MESSAGE, parse_mode="Markdown")
        # [NOVO v6] Envia fotos VIP
        await send_vip_welcome_photos(context.bot, uid)
    except:
        pass

async def stats_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id not in ADMIN_IDS:
        return
    
    users = get_all_active_users()
    total = len(users)
    vips = sum(1 for uid in users if is_vip(uid))
    paused = sum(1 for uid in users if is_engagement_paused(uid))
    slots = get_vip_slots()
    
    await update.message.reply_text(
        f"üìä **ESTAT√çSTICAS**\n\n"
        f"üë• Usu√°rios: {total}\n"
        f"üíé VIPs: {vips}\n"
        f"‚è∏Ô∏è Pausados: {paused}\n"
        f"üìà Convers√£o: {(vips/total*100) if total > 0 else 0:.1f}%\n"
        f"üé´ Vagas restantes: {slots}",
        parse_mode="Markdown"
    )

async def funnel_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id not in ADMIN_IDS:
        return
    
    stages = get_funnel_stats()
    names = {
        0: "‚ùì Desconhecido", 1: "üöÄ /start", 2: "üåç Idioma",
        3: "üí¨ 1¬™ msg", 4: "‚ö†Ô∏è Aviso", 5: "üö´ Limite",
        6: "üí≥ PIX", 7: "‚≠ê Stars", 8: "üì∏ Comprovante", 9: "üíé VIP"
    }
    
    msg = "üìä **FUNIL**\n\n"
    for stage, count in sorted(stages.items()):
        msg += f"{names.get(stage, f'Stage {stage}')}: {count}\n"
    
    await update.message.reply_text(msg, parse_mode="Markdown")

# ================= BROADCAST OTIMIZADO =================
async def broadcast_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id not in ADMIN_IDS:
        return
    if not context.args:
        await update.message.reply_text("Uso: /broadcast <mensagem>")
        return
    
    message = " ".join(context.args)
    users = get_all_active_users()
    
    # Filtrar usu√°rios eleg√≠veis antecipadamente
    eligible_users = []
    for uid in users:
        if is_blacklisted(uid):
            continue
        hours_inactive = get_hours_since_activity(uid)
        if hours_inactive is None or hours_inactive > 168:
            continue
        eligible_users.append(uid)
    
    total = len(eligible_users)
    if total == 0:
        await update.message.reply_text("‚ùå Nenhum usu√°rio eleg√≠vel")
        return
    
    status_msg = await update.message.reply_text(
        f"üì§ Iniciando broadcast para {total} usu√°rios..."
    )
    
    # Contadores thread-safe
    sent = failed = 0
    sent_lock = asyncio.Lock()
    
    # Sem√°foro para controlar taxa (20 envios simult√¢neos)
    semaphore = asyncio.Semaphore(20)
    
    async def send_to_user(uid):
        nonlocal sent, failed
        async with semaphore:
            try:
                await context.bot.send_message(chat_id=uid, text=message)
                async with sent_lock:
                    sent += 1
                # Sleep m√≠nimo para respeitar limites da API
                await asyncio.sleep(0.03)
            except Exception as e:
                async with sent_lock:
                    failed += 1
                if "blocked" in str(e).lower() or "403" in str(e):
                    add_to_blacklist(uid)
                    logger.info(f"üö´ {uid} bloqueou o bot")
    
    # Processar em lotes de 100 para atualizar progresso
    batch_size = 100
    for i in range(0, total, batch_size):
        batch = eligible_users[i:i + batch_size]
        
        # Enviar lote em paralelo
        await asyncio.gather(*[send_to_user(uid) for uid in batch])
        
        # Atualizar progresso
        progress = min(i + batch_size, total)
        try:
            await status_msg.edit_text(
                f"üì§ Enviando... {progress}/{total}\n"
                f"‚úÖ {sent} | ‚ùå {failed}"
            )
        except:
            pass
    
    # Resultado final
    await status_msg.edit_text(
        f"‚úÖ **BROADCAST CONCLU√çDO**\n\n"
        f"üìä Total: {total}\n"
        f"‚úÖ Enviados: {sent}\n"
        f"‚ùå Falhas: {failed}\n"
        f"‚ö° Taxa: {sent/(total/20):.1f}x mais r√°pido",
        parse_mode="Markdown"
    )

async def send_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id not in ADMIN_IDS:
        return
    
    if len(context.args) < 2:
        await update.message.reply_text("Uso: /send <user_id> <mensagem>")
        return
    
    try:
        uid = int(context.args[0])
        message = " ".join(context.args[1:])
        
        await context.bot.send_message(chat_id=uid, text=message)
        await update.message.reply_text(f"‚úÖ Mensagem enviada para {uid}")
    except Exception as e:
        await update.message.reply_text(f"‚ùå Erro: {e}")

async def sendphoto_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id not in ADMIN_IDS:
        return
    
    if not context.args:
        await update.message.reply_text(
            "üì∏ **Como usar:**\n\n"
            "1Ô∏è‚É£ Envie uma foto ou documento\n"
            "2Ô∏è‚É£ Responda com `/sendphoto <user_id> [legenda]`\n\n"
            "Exemplo: `/sendphoto 123456789 Olha isso! üíï`",
            parse_mode="Markdown"
        )
        return
    
    if not update.message.reply_to_message:
        await update.message.reply_text("‚ùå Responda a uma foto ou documento com este comando")
        return
    
    reply = update.message.reply_to_message
    
    try:
        uid = int(context.args[0])
        caption = " ".join(context.args[1:]) if len(context.args) > 1 else None
        
        if reply.photo:
            await context.bot.send_photo(
                chat_id=uid,
                photo=reply.photo[-1].file_id,
                caption=caption
            )
            await update.message.reply_text(f"‚úÖ Foto enviada para {uid}")
        
        elif reply.document:
            await context.bot.send_document(
                chat_id=uid,
                document=reply.document.file_id,
                caption=caption
            )
            await update.message.reply_text(f"‚úÖ Documento enviado para {uid}")
        
        elif reply.video:
            await context.bot.send_video(
                chat_id=uid,
                video=reply.video.file_id,
                caption=caption
            )
            await update.message.reply_text(f"‚úÖ V√≠deo enviado para {uid}")
        
        elif reply.audio:
            await context.bot.send_audio(
                chat_id=uid,
                audio=reply.audio.file_id,
                caption=caption
            )
            await update.message.reply_text(f"‚úÖ √Åudio enviado para {uid}")
        
        elif reply.voice:
            await context.bot.send_voice(
                chat_id=uid,
                voice=reply.voice.file_id,
                caption=caption
            )
            await update.message.reply_text(f"‚úÖ Mensagem de voz enviada para {uid}")
        
        elif reply.video_note:
            await context.bot.send_video_note(
                chat_id=uid,
                video_note=reply.video_note.file_id
            )
            await update.message.reply_text(f"‚úÖ Video note enviado para {uid}")
        
        elif reply.sticker:
            await context.bot.send_sticker(
                chat_id=uid,
                sticker=reply.sticker.file_id
            )
            await update.message.reply_text(f"‚úÖ Sticker enviado para {uid}")
        
        else:
            await update.message.reply_text("‚ùå Tipo de m√≠dia n√£o suportado. Use foto, documento, v√≠deo ou √°udio.")
            
    except ValueError:
        await update.message.reply_text("‚ùå ID de usu√°rio inv√°lido")
    except Exception as e:
        await update.message.reply_text(f"‚ùå Erro: {e}")

async def migrate_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id not in ADMIN_IDS:
        return
    
    await update.message.reply_text("üîÑ Migrando...")
    
    migrated = 0
    all_uids = set()
    
    for key in r.keys("memory:*"):
        uid = key.replace("memory:", "")
        if uid.isdigit():
            all_uids.add(uid)
    
    for key in r.keys("lang:*"):
        uid = key.replace("lang:", "")
        if uid.isdigit():
            all_uids.add(uid)
    
    for uid in all_uids:
        r.sadd(all_users_key(), uid)
        if not r.exists(last_activity_key(int(uid))):
            r.set(last_activity_key(int(uid)), (datetime.now() - timedelta(hours=25)).isoformat())
        migrated += 1
    
    await update.message.reply_text(f"‚úÖ {migrated} usu√°rios migrados")

async def status_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_user.id
    
    if update.effective_user.id in ADMIN_IDS and context.args:
        uid = int(context.args[0])
    
    streak = get_streak(uid)
    count = today_count(uid)
    bonus = get_bonus_msgs(uid)
    vip_status = is_vip(uid)
    vip_expiry = get_vip_expiry(uid)
    ignored = get_ignored_count(uid)
    paused = is_engagement_paused(uid)
    
    msg = f"üìã **STATUS**\n\n"
    msg += f"üë§ ID: `{uid}`\n"
    msg += f"üî• Streak: {streak} dias\n"
    msg += f"üí¨ Msgs hoje: {count}/{LIMITE_DIARIO}\n"
    if bonus > 0:
        msg += f"üéÅ Msgs b√¥nus: {bonus}\n"
    
    if vip_status:
        msg += f"üíé VIP: ‚úÖ (at√© {vip_expiry.strftime('%d/%m/%Y')})\n"
    else:
        msg += f"üíé VIP: ‚ùå\n"
        msg += f"üìä Restam: {max(0, LIMITE_DIARIO + bonus - count)} msgs\n"
    
    msg += f"\nüîî **Engajamento:**\n"
    msg += f"‚Ä¢ Ignorou: {ignored}/3\n"
    msg += f"‚Ä¢ Pausado: {'‚è∏Ô∏è Sim' if paused else '‚ñ∂Ô∏è N√£o'}"
    
    await update.message.reply_text(msg, parse_mode="Markdown")

async def viplist_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id not in ADMIN_IDS:
        return
    
    users = get_all_active_users()
    vips = []
    
    for uid in users:
        if is_vip(uid):
            expiry = get_vip_expiry(uid)
            vips.append((uid, expiry))
    
    if not vips:
        await update.message.reply_text("Nenhum VIP ativo")
        return
    
    msg = "üíé **VIPs ATIVOS**\n\n"
    for uid, expiry in sorted(vips, key=lambda x: x[1]):
        msg += f"‚Ä¢ `{uid}` ‚Üí at√© {expiry.strftime('%d/%m/%Y')}\n"
    
    await update.message.reply_text(msg, parse_mode="Markdown")

async def userinfo_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id not in ADMIN_IDS:
        return
    if not context.args:
        await update.message.reply_text("Uso: /userinfo <user_id>")
        return
    
    uid = int(context.args[0])
    
    profile = get_user_profile(uid)
    streak = get_streak(uid)
    count = today_count(uid)
    bonus = get_bonus_msgs(uid)
    vip_status = is_vip(uid)
    vip_expiry = get_vip_expiry(uid)
    last_activity = get_last_activity(uid)
    funnel_stage = int(r.get(funnel_key(uid)) or 0)
    memory_count = len(get_memory(uid))
    ignored = get_ignored_count(uid)
    paused = is_engagement_paused(uid)
    onboard_choice = get_onboarding_choice(uid)  # [NOVO v6]
    
    msg = f"üë§ **USU√ÅRIO {uid}**\n\n"
    msg += f"üìù Nome: {profile.get('name', 'N/A')}\n"
    msg += f"üéÇ Idade: {profile.get('age', 'N/A')}\n"
    msg += f"üéØ Onboarding: {onboard_choice or 'N/A'}\n"  # [NOVO v6]
    msg += f"üî• Streak: {streak} dias\n"
    msg += f"üí¨ Msgs hoje: {count}/{LIMITE_DIARIO}\n"
    msg += f"üéÅ B√¥nus: {bonus}\n"
    msg += f"üß† Mem√≥ria: {memory_count} msgs\n"
    msg += f"üìä Funil: {funnel_stage}/9\n"
    
    if vip_status:
        msg += f"üíé VIP: ‚úÖ at√© {vip_expiry.strftime('%d/%m/%Y')}\n"
    else:
        msg += f"üíé VIP: ‚ùå\n"
    
    if last_activity:
        hours_ago = (datetime.now() - last_activity).total_seconds() / 3600
        msg += f"‚è∞ √öltima atividade: {hours_ago:.1f}h atr√°s\n"
    
    msg += f"\nüîî **Engajamento:**\n"
    msg += f"‚Ä¢ Ignorou: {ignored}/3\n"
    msg += f"‚Ä¢ Pausado: {'‚è∏Ô∏è Sim' if paused else '‚ñ∂Ô∏è N√£o'}\n"
    
    if is_blacklisted(uid):
        msg += f"\nüö´ BLOQUEADO\n"
    
    await update.message.reply_text(msg, parse_mode="Markdown")

async def givebonus_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id not in ADMIN_IDS:
        return
    if len(context.args) < 2:
        await update.message.reply_text("Uso: /givebonus <user_id> <quantidade>")
        return
    
    uid = int(context.args[0])
    amount = int(context.args[1])
    
    add_bonus_msgs(uid, amount)
    await update.message.reply_text(f"‚úÖ +{amount} msgs b√¥nus para {uid}\n(Total: {get_bonus_msgs(uid)})")
    
    try:
        await context.bot.send_message(
            uid, f"üéÅ Voc√™ ganhou +{amount} mensagens extras! Aproveite üíï"
        )
    except:
        pass

async def blacklist_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id not in ADMIN_IDS:
        return
    if not context.args:
        await update.message.reply_text("Uso: /blacklist <user_id>")
        return
    
    uid = int(context.args[0])
    add_to_blacklist(uid)
    await update.message.reply_text(f"üö´ Usu√°rio {uid} bloqueado")

async def unblacklist_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id not in ADMIN_IDS:
        return
    if not context.args:
        await update.message.reply_text("Uso: /unblacklist <user_id>")
        return
    
    uid = int(context.args[0])
    remove_from_blacklist(uid)
    await update.message.reply_text(f"‚úÖ Usu√°rio {uid} desbloqueado")

async def unpause_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id not in ADMIN_IDS:
        return
    if not context.args:
        await update.message.reply_text("Uso: /unpause <user_id>")
        return
    
    uid = int(context.args[0])
    unpause_engagement(uid)
    await update.message.reply_text(f"‚ñ∂Ô∏è Gatilhos reativados para {uid}")

async def pausedlist_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id not in ADMIN_IDS:
        return
    
    users = get_all_active_users()
    paused_users = []
    
    for uid in users:
        if is_engagement_paused(uid):
            paused_users.append(uid)
    
    if not paused_users:
        await update.message.reply_text("Nenhum usu√°rio com gatilhos pausados")
        return
    
    msg = f"‚è∏Ô∏è **USU√ÅRIOS PAUSADOS** ({len(paused_users)})\n\n"
    for uid in paused_users[:50]:
        msg += f"‚Ä¢ `{uid}`\n"
    
    if len(paused_users) > 50:
        msg += f"\n... e mais {len(paused_users) - 50}"
    
    await update.message.reply_text(msg, parse_mode="Markdown")

# ================= CONFIGURA√á√ÉO DO BOT =================
def setup_application():
    application = Application.builder().token(TELEGRAM_TOKEN).build()
    
    # Comandos usu√°rio
    application.add_handler(CommandHandler("start", start_handler))
    application.add_handler(CommandHandler("status", status_cmd))
    
    # Comandos admin
    application.add_handler(CommandHandler("reset", reset_cmd))
    application.add_handler(CommandHandler("resetall", resetall_cmd))
    application.add_handler(CommandHandler("clearmemory", clearmemory_cmd))
    application.add_handler(CommandHandler("setvip", setvip_cmd))
    application.add_handler(CommandHandler("stats", stats_cmd))
    application.add_handler(CommandHandler("funnel", funnel_cmd))
    application.add_handler(CommandHandler("broadcast", broadcast_cmd))
    application.add_handler(CommandHandler("send", send_cmd))
    application.add_handler(CommandHandler("sendphoto", sendphoto_cmd))
    application.add_handler(CommandHandler("migrate", migrate_cmd))
    application.add_handler(CommandHandler("viplist", viplist_cmd))
    application.add_handler(CommandHandler("userinfo", userinfo_cmd))
    application.add_handler(CommandHandler("givebonus", givebonus_cmd))
    application.add_handler(CommandHandler("blacklist", blacklist_cmd))
    application.add_handler(CommandHandler("unblacklist", unblacklist_cmd))
    application.add_handler(CommandHandler("unpause", unpause_cmd))
    application.add_handler(CommandHandler("pausedlist", pausedlist_cmd))
    
    # Handlers
    application.add_handler(CallbackQueryHandler(callback_handler))
    application.add_handler(PreCheckoutQueryHandler(pre_checkout))
    application.add_handler(MessageHandler(filters.SUCCESSFUL_PAYMENT, payment_success))
    application.add_handler(MessageHandler(
        (filters.TEXT | filters.PHOTO | filters.Document.ALL) & ~filters.COMMAND,
        message_handler
    ))
    
    logger.info("‚úÖ Handlers registrados")
    return application

# ================= FLASK APP =================
app = Flask(__name__)
application = setup_application()

loop = asyncio.new_event_loop()
asyncio.set_event_loop(loop)

def start_loop():
    loop.run_forever()

import threading
threading.Thread(target=start_loop, daemon=True).start()

scheduler_started = False

@app.route("/", methods=["GET"])
def health():
    return "ok", 200

@app.route("/set-webhook", methods=["GET"])
def set_webhook_route():
    asyncio.run_coroutine_threadsafe(setup_webhook(), loop)
    return "Webhook configurado", 200

@app.route("/trigger-engagement", methods=["GET"])
def trigger_engagement():
    asyncio.run_coroutine_threadsafe(process_engagement_jobs(application.bot), loop)
    return "Jobs disparados", 200

@app.route(WEBHOOK_PATH, methods=["POST"])
def telegram_webhook():
    try:
        data = request.json
        if not data:
            return "ok", 200
        update = Update.de_json(data, application.bot)
        asyncio.run_coroutine_threadsafe(application.process_update(update), loop)
        return "ok", 200
    except Exception as e:
        logger.exception(f"Erro webhook: {e}")
        return "error", 500

async def setup_webhook():
    global scheduler_started
    try:
        await application.bot.delete_webhook(drop_pending_updates=True)
        webhook_url = f"{WEBHOOK_BASE_URL}{WEBHOOK_PATH}"
        await application.bot.set_webhook(webhook_url)
        logger.info(f"‚úÖ Webhook: {webhook_url}")
        
        if not scheduler_started:
            asyncio.create_task(engagement_scheduler(application.bot))
            scheduler_started = True
    except Exception as e:
        logger.error(f"Erro webhook: {e}")

if __name__ == "__main__":
    asyncio.run_coroutine_threadsafe(application.initialize(), loop)
    asyncio.run_coroutine_threadsafe(application.start(), loop)
    asyncio.run_coroutine_threadsafe(engagement_scheduler(application.bot), loop)
    logger.info(f"üåê Flask porta {PORT}")
    app.run(host="0.0.0.0", port=PORT, debug=False, use_reloader=False)
