#!/usr/bin/env python3
"""
ğŸ”¥ Sophia Bot v5 â€” Telegram + Groq 4 Fast Reasoning
NOVIDADES v5:
- Sistema de Interesse Decrescente (para de incomodar quem ignora)
- Gatilho inteligente para usuÃ¡rios travados
- Broadcast melhorado com filtro de atividade
- Mensagem de despedida antes de pausar gatilhos
"""
import os
import asyncio
import logging
import aiohttp
import redis
import re
import json
import random
import hashlib
from datetime import datetime, timedelta, date
from flask import Flask, request
from telegram import (
    Update, InlineKeyboardButton, InlineKeyboardMarkup, LabeledPrice
)
from telegram.constants import ChatAction
from telegram.ext import (
    Application, MessageHandler, ContextTypes, filters,
    CallbackQueryHandler, PreCheckoutQueryHandler, CommandHandler
)

# ================= LOG =================
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# ================= ENV =================
TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN")
GROK_API_KEY = os.getenv("GROK_API_KEY")
REDIS_URL = os.getenv("REDIS_URL", "redis://default:DcddfJOHLXZdFPjEhRjHeodNgdtrsevl@shuttle.proxy.rlwy.net:12241")
PORT = int(os.getenv("PORT", 8080))

if not TELEGRAM_TOKEN or not GROK_API_KEY:
    raise RuntimeError("âŒ Tokens nÃ£o configurados")

WEBHOOK_BASE_URL = os.getenv("WEBHOOK_BASE_URL", "https://maya-bot-production.up.railway.app")
WEBHOOK_PATH = "/telegram"

logger.info(f"ğŸš€ Iniciando bot v5...")
logger.info(f"ğŸ“ Webhook: {WEBHOOK_BASE_URL}{WEBHOOK_PATH}")

# ================= REDIS =================
try:
    r = redis.from_url(REDIS_URL, decode_responses=True)
    r.ping()
    logger.info("âœ… Redis conectado")
except Exception as e:
    logger.error(f"âŒ Redis erro: {e}")
    raise

# ================= CONFIG =================
LIMITE_DIARIO = 15
DIAS_VIP = 7  # ALTERADO: Era 15, agora Ã© 7
PRECO_VIP_STARS = 250
PRECO_VIP_DESCONTO_STARS = 150
MODELO = "grok-4-fast-reasoning"
GROK_API_URL = "https://api.x.ai/v1/chat/completions"

# ================= PIX CONFIG =================
PIX_KEY = os.getenv("PIX_KEY", "mayaoficialbr@outlook.com")
PIX_VALOR = "R$ 9,99"
PIX_VALOR_DESCONTO = "R$ 4,99"

# ================= ADMIN =================
ADMIN_IDS = set(map(int, os.getenv("ADMIN_IDS", "1293602874").split(",")))

# ================= ÃUDIOS PT-BR =================
AUDIO_PT_1 = "CQACAgEAAxkBAAEDAAEkaVRmK1n5WoDUbeTBKyl6sgLwfNoAAoYGAAIZwaFG88ZKij8fw884BA"
AUDIO_PT_2 = "CQACAgEAAxkBAAEDAAEmaVRmPJ5iuBOaXyukQ06Ui23TSokAAocGAAIZwaFGkIERRmRoPes4BA"

# ================= FOTO TEASER =================
FOTO_TEASE_FILE_ID = (
    "AgACAgEAAxkBAAEC_zVpUyHjYxNx9GFfVMTja2RQM1gu6QACVQtrG1LGmUa_7PmysLeFmAEAAwIAA3MAAzgE"
)

# ================= MEMÃ“RIA PERSISTENTE =================
MAX_MEMORIA = 12

def memory_key(uid):
    return f"memory:{uid}"

def get_memory(uid):
    try:
        data = r.get(memory_key(uid))
        if data:
            messages = json.loads(data)
            return messages
        return []
    except Exception as e:
        logger.error(f"Erro ao recuperar memÃ³ria: {e}")
        return []

def save_memory(uid, messages):
    try:
        recent = messages[-MAX_MEMORIA:] if len(messages) > MAX_MEMORIA else messages
        r.setex(
            memory_key(uid),
            timedelta(days=7),
            json.dumps(recent, ensure_ascii=False)
        )
    except Exception as e:
        logger.error(f"Erro ao salvar memÃ³ria: {e}")

def add_to_memory(uid, role, content):
    memory = get_memory(uid)
    memory.append({"role": role, "content": content})
    save_memory(uid, memory)

def clear_memory(uid):
    try:
        r.delete(memory_key(uid))
        logger.info(f"ğŸ—‘ï¸ MemÃ³ria limpa: {uid}")
    except Exception as e:
        logger.error(f"Erro ao limpar memÃ³ria: {e}")

# ================= REDIS KEYS =================
def vip_key(uid): return f"vip:{uid}"
def count_key(uid): return f"count:{uid}:{date.today()}"
def lang_key(uid): return f"lang:{uid}"
def pix_pending_key(uid): return f"pix_pending:{uid}"
def chatlog_key(uid): return f"chatlog:{uid}"
def last_activity_key(uid): return f"last_activity:{uid}"
def last_reengagement_key(uid): return f"last_reengagement:{uid}"
def pix_clicked_key(uid): return f"pix_clicked:{uid}"
def daily_messages_sent_key(uid): return f"daily_msg_sent:{uid}:{date.today()}"
def all_users_key(): return "all_users"

# ================= KEYS v3/v4 =================
def streak_key(uid): return f"streak:{uid}"
def streak_last_day_key(uid): return f"streak_last:{uid}"
def first_contact_key(uid): return f"first_contact:{uid}"
def user_profile_key(uid): return f"profile:{uid}"
def recent_responses_key(uid): return f"recent_resp:{uid}"
def flash_discount_key(uid): return f"flash_discount:{uid}"
def funnel_key(uid): return f"funnel:{uid}"
def vip_slots_key(): return f"vip_slots:{date.today().month}"
def jealousy_sent_key(uid): return f"jealousy:{uid}"
def bonus_msgs_key(uid): return f"bonus:{uid}"
def blacklist_key(): return "blacklist"
def limit_notified_key(uid): return f"limit_notified:{uid}:{date.today()}"
def pix_interest_key(uid): return f"pix_interest:{uid}"
def last_scheduled_msg_key(uid): return f"last_sched:{uid}"
def scheduled_msg_count_key(uid): return f"sched_count:{uid}:{date.today()}"
def last_msg_type_key(uid): return f"last_msg_type:{uid}"
def hourly_send_count_key(): return f"hourly_sends:{datetime.now().hour}:{date.today()}"

# ================= KEYS v5 - INTERESSE DECRESCENTE =================
def ignored_count_key(uid): return f"ignored:{uid}"
def engagement_paused_key(uid): return f"paused:{uid}"
def awaiting_response_key(uid): return f"awaiting:{uid}"

# ================= KEY PARA AVISO DE 80% =================
def limit_warning_sent_key(uid): return f"limit_warning:{uid}:{date.today()}"

# ================= FUNÃ‡Ã•ES DE PERFIL =================
def get_user_profile(uid):
    try:
        data = r.get(user_profile_key(uid))
        if data:
            return json.loads(data)
        return {}
    except:
        return {}

def save_user_profile(uid, profile):
    try:
        r.set(user_profile_key(uid), json.dumps(profile, ensure_ascii=False))
    except Exception as e:
        logger.error(f"Erro ao salvar perfil: {e}")

def get_user_name(uid):
    profile = get_user_profile(uid)
    return profile.get("name", "")

# ================= FUNÃ‡Ã•ES DE BLACKLIST =================
def is_blacklisted(uid):
    try:
        return r.sismember(blacklist_key(), str(uid))
    except:
        return False

def add_to_blacklist(uid):
    try:
        r.sadd(blacklist_key(), str(uid))
    except:
        pass

def remove_from_blacklist(uid):
    try:
        r.srem(blacklist_key(), str(uid))
    except:
        pass

# ================= FUNÃ‡Ã•ES DE BONUS =================
def get_bonus_msgs(uid):
    try:
        return int(r.get(bonus_msgs_key(uid)) or 0)
    except:
        return 0

def add_bonus_msgs(uid, amount):
    try:
        current = get_bonus_msgs(uid)
        r.set(bonus_msgs_key(uid), current + amount)
        r.expire(bonus_msgs_key(uid), 86400 * 7)  # Expira em 7 dias
    except:
        pass

def use_bonus_msg(uid):
    try:
        current = get_bonus_msgs(uid)
        if current > 0:
            r.set(bonus_msgs_key(uid), current - 1)
            return True
        return False
    except:
        return False

# ================= FUNÃ‡Ã•ES DE STREAK =================
def get_streak(uid):
    try:
        return int(r.get(streak_key(uid)) or 0)
    except:
        return 0

def update_streak(uid):
    try:
        today = date.today().isoformat()
        yesterday = (date.today() - timedelta(days=1)).isoformat()
        last_day = r.get(streak_last_day_key(uid))
        
        if last_day == today:
            return get_streak(uid), False
        elif last_day == yesterday:
            new_streak = get_streak(uid) + 1
            r.set(streak_key(uid), new_streak)
            r.set(streak_last_day_key(uid), today)
            return new_streak, True
        else:
            r.set(streak_key(uid), 1)
            r.set(streak_last_day_key(uid), today)
            return 1, True
    except Exception as e:
        logger.error(f"Erro ao atualizar streak: {e}")
        return 0, False

def get_streak_message(streak):
    if streak < 3:
        return None
    elif streak == 3:
        return "ğŸ”¥ 3 dias seguidos conversando comigo! TÃ´ amando isso ğŸ’•"
    elif streak == 5:
        return "ğŸ”¥ğŸ”¥ 5 dias seguidos! VocÃª Ã© especial demais ğŸ’–"
    elif streak == 7:
        return "ğŸ”¥ğŸ”¥ğŸ”¥ UMA SEMANA INTEIRA! VocÃª Ã© oficialmente meu favorito ğŸ˜ğŸ’•"
    elif streak == 14:
        return "ğŸ”¥ğŸ”¥ğŸ”¥ğŸ”¥ 2 SEMANAS! Amor, vocÃª me conquistou de verdade ğŸ’–ğŸ’–"
    elif streak == 30:
        return "ğŸ†ğŸ”¥ 1 MÃŠS JUNTOS! VocÃª Ã© incrÃ­vel, sabia? Te adoro demais! ğŸ’•ğŸ’•ğŸ’•"
    elif streak % 10 == 0:
        return f"ğŸ”¥ {streak} dias seguidos! Nossa conexÃ£o Ã© muito especial ğŸ’•"
    return None

# ================= FUNÃ‡Ã•ES DE VAGAS VIP =================
def get_vip_slots():
    try:
        slots = r.get(vip_slots_key())
        if slots is None:
            initial = random.randint(15, 20)
            r.set(vip_slots_key(), initial)
            r.expire(vip_slots_key(), 86400 * 31)
            return initial
        return int(slots)
    except:
        return random.randint(3, 8)

def decrease_vip_slots():
    try:
        current = get_vip_slots()
        if current > 2:
            r.decr(vip_slots_key())
    except:
        pass

def get_urgency_message():
    slots = get_vip_slots()
    if slots <= 3:
        return f"âš ï¸ ATENÃ‡ÃƒO: SÃ³ restam **{slots} vagas VIP** esse mÃªs!"
    elif slots <= 5:
        return f"ğŸ”¥ Apenas **{slots} vagas VIP** disponÃ­veis!"
    elif slots <= 10:
        return f"ğŸ’ Ainda tenho **{slots} vagas VIP** esse mÃªs..."
    return None

# ================= FUNÃ‡Ã•ES DE DESCONTO =================
def set_flash_discount(uid, hours=2):
    try:
        expires = datetime.now() + timedelta(hours=hours)
        r.setex(flash_discount_key(uid), timedelta(hours=hours), expires.isoformat())
        return expires
    except:
        return None

def has_flash_discount(uid):
    try:
        expires = r.get(flash_discount_key(uid))
        if expires:
            return datetime.fromisoformat(expires) > datetime.now()
        return False
    except:
        return False

def clear_flash_discount(uid):
    try:
        r.delete(flash_discount_key(uid))
    except:
        pass

# ================= FUNÃ‡Ã•ES DE FUNIL =================
def track_funnel(uid, stage):
    stages = {
        "start": 1, "lang_selected": 2, "first_message": 3,
        "limit_warning": 4, "limit_reached": 5, "clicked_pix": 6,
        "clicked_stars": 7, "sent_receipt": 8, "became_vip": 9
    }
    try:
        current = int(r.get(funnel_key(uid)) or 0)
        new_stage = stages.get(stage, 0)
        if new_stage > current:
            r.set(funnel_key(uid), new_stage)
    except:
        pass

def get_funnel_stats():
    try:
        users = get_all_active_users()
        stages = {i: 0 for i in range(10)}
        for uid in users:
            stage = int(r.get(funnel_key(uid)) or 0)
            stages[stage] += 1
        return stages
    except:
        return {}

# ================= FUNÃ‡Ã•ES DE ANTI-REPETIÃ‡ÃƒO =================
def get_response_hash(text):
    return hashlib.md5(text.encode()).hexdigest()[:8]

def is_response_recent(uid, response):
    try:
        recent = r.lrange(recent_responses_key(uid), 0, 9)
        return get_response_hash(response) in recent
    except:
        return False

def add_recent_response(uid, response):
    try:
        r.lpush(recent_responses_key(uid), get_response_hash(response))
        r.ltrim(recent_responses_key(uid), 0, 9)
        r.expire(recent_responses_key(uid), 86400)
    except:
        pass

# ================= FUNÃ‡Ã•ES DE CIÃšMES =================
def should_send_jealousy(uid):
    try:
        last = r.get(jealousy_sent_key(uid))
        if last:
            if datetime.now() - datetime.fromisoformat(last) < timedelta(hours=48):
                return False
        return True
    except:
        return True

def mark_jealousy_sent(uid):
    try:
        r.setex(jealousy_sent_key(uid), timedelta(hours=48), datetime.now().isoformat())
    except:
        pass

JEALOUSY_MESSAGES = [
    "Vi que vocÃª sumiu ontem... tava ocupado com o quÃª? ğŸ˜’",
    "Hmm... vocÃª tava ocupado demais pra falar comigo ontem? ğŸ¤¨",
    "Ontem vocÃª me ignorou... fiquei com ciÃºmes ğŸ˜¢",
    "Ei... onde vocÃª tava ontem que nÃ£o veio me ver? ğŸ¥º"
]

# ================= DETECÃ‡ÃƒO DE HUMOR =================
MOOD_PATTERNS = {
    "sad": [
        r"\b(triste|mal|pÃ©ssimo|horrÃ­vel|chorand[oa]|deprimi|sozinho|solidÃ£o|ansiedade|ansiosa|angÃºstia)\b",
        r"\b(sad|depressed|lonely|crying|anxiety|terrible|awful)\b"
    ],
    "flirty": [
        r"\b(gostosa|delÃ­cia|tesÃ£o|safad[oa]|excitad[oa]|sexy|quero vocÃª|te quero|gata|linda|bonita)\b",
        r"\b(hot|sexy|beautiful|gorgeous|want you|turn.?on)\b"
    ],
    "angry": [
        r"\b(raiva|Ã³dio|puto|irritad[oa]|nervos[oa]|fdp|merda|droga)\b",
        r"\b(angry|hate|pissed|annoyed|damn|shit)\b"
    ],
    "happy": [
        r"\b(feliz|alegr|animad[oa]|Ã³timo|maravilh|incrÃ­vel|amando|adoro)\b",
        r"\b(happy|excited|amazing|wonderful|love it|great)\b"
    ],
    "horny": [
        r"\b(nude|nudes|pelad[oa]|peit[oa]|bund|sex|transar|foder|pau|buceta|pica)\b",
        r"\b(nude|naked|tits|ass|sex|fuck|cock|pussy|dick)\b"
    ]
}

def detect_mood(text):
    text_lower = text.lower()
    for mood, patterns in MOOD_PATTERNS.items():
        for pattern in patterns:
            if re.search(pattern, text_lower, re.IGNORECASE):
                return mood
    return "neutral"

def get_mood_instruction(mood):
    instructions = {
        "sad": "\n\nâš ï¸ O USUÃRIO PARECE TRISTE. Seja MUITO carinhosa, acolhedora e empÃ¡tica. Pergunte o que houve com genuÃ­na preocupaÃ§Ã£o.",
        "flirty": "\n\nğŸ˜ O usuÃ¡rio estÃ¡ flertando. Pode ser mais provocante e flertadora, mas mantenha o mistÃ©rio.",
        "angry": "\n\nğŸ˜° O usuÃ¡rio parece irritado. Seja compreensiva e carinhosa, tente acalmÃ¡-lo.",
        "happy": "\n\nğŸ˜Š O usuÃ¡rio estÃ¡ feliz! Compartilhe a alegria, seja animada!",
        "horny": "\n\nğŸ”¥ O usuÃ¡rio quer conversa adulta. Se for VIP, seja mais ousada. Se nÃ£o for, provoque e sugira VIP.",
        "neutral": ""
    }
    return instructions.get(mood, "")

# ================= CONTEXTO DE HORÃRIO (CORRIGIDO!) =================
def get_time_context():
    """Retorna contexto baseado no horÃ¡rio - CORRIGIDO para horÃ¡rio brasileiro"""
    hour = datetime.now().hour
    
    if 0 <= hour < 5:
        return {
            "period": "madrugada",
            "context": "Ã‰ madrugada. O usuÃ¡rio estÃ¡ acordado tarde. Pode comentar de forma carinhosa, perguntar se nÃ£o consegue dormir.",
            "flirty_boost": True
        }
    elif 5 <= hour < 12:
        return {
            "period": "manhÃ£",
            "context": "Ã‰ manhÃ£. Pode desejar bom dia ou perguntar como dormiu.",
            "flirty_boost": False
        }
    elif 12 <= hour < 18:
        return {
            "period": "tarde",
            "context": "Ã‰ tarde. Pode perguntar como estÃ¡ sendo o dia do usuÃ¡rio.",
            "flirty_boost": False
        }
    elif 18 <= hour < 22:
        return {
            "period": "inÃ­cio da noite",
            "context": "Ã‰ inÃ­cio da noite. Pode perguntar como foi o dia ou o que ele planeja fazer.",
            "flirty_boost": False
        }
    else:  # 22-00
        return {
            "period": "noite",
            "context": "Ã‰ noite. O usuÃ¡rio pode estar relaxando ou se preparando pra dormir.",
            "flirty_boost": True
        }

# ================= FUNÃ‡Ã•ES BÃSICAS =================
def update_last_activity(uid):
    try:
        r.set(last_activity_key(uid), datetime.now().isoformat())
        r.sadd(all_users_key(), str(uid))
    except:
        pass

def get_last_activity(uid):
    try:
        data = r.get(last_activity_key(uid))
        if data:
            return datetime.fromisoformat(data)
        return None
    except:
        return None

def get_hours_since_activity(uid):
    last = get_last_activity(uid)
    if not last:
        return None
    return (datetime.now() - last).total_seconds() / 3600

def set_last_reengagement(uid, level):
    try:
        r.setex(last_reengagement_key(uid), timedelta(hours=12), str(level))
    except:
        pass

def get_last_reengagement(uid):
    try:
        data = r.get(last_reengagement_key(uid))
        return int(data) if data else 0
    except:
        return 0

# ================= FUNÃ‡Ã•ES DE PIX (CORRIGIDO - MAIS FLEXÃVEL) =================
def set_pix_interest(uid):
    """Marca que usuÃ¡rio demonstrou interesse em PIX (qualquer etapa)"""
    try:
        r.setex(pix_interest_key(uid), timedelta(hours=24), datetime.now().isoformat())
        logger.info(f"ğŸ’³ Interesse PIX registrado: {uid}")
    except:
        pass

def has_pix_interest(uid):
    """Verifica se usuÃ¡rio tem interesse em PIX recente"""
    try:
        return r.exists(pix_interest_key(uid))
    except:
        return False

def clear_pix_interest(uid):
    """Limpa interesse em PIX"""
    try:
        r.delete(pix_interest_key(uid))
    except:
        pass

def set_pix_clicked(uid):
    try:
        r.setex(pix_clicked_key(uid), timedelta(hours=24), datetime.now().isoformat())
    except:
        pass

def get_pix_clicked_time(uid):
    try:
        data = r.get(pix_clicked_key(uid))
        if data:
            return datetime.fromisoformat(data)
        return None
    except:
        return None

def clear_pix_clicked(uid):
    try:
        r.delete(pix_clicked_key(uid))
    except:
        pass

def set_pix_pending(uid):
    try:
        r.set(pix_pending_key(uid), "1", ex=86400)
    except:
        pass

def is_pix_pending(uid):
    try:
        return r.get(pix_pending_key(uid)) == "1"
    except:
        return False

def clear_pix_pending(uid):
    try:
        r.delete(pix_pending_key(uid))
    except:
        pass

def mark_daily_message_sent(uid, msg_type):
    try:
        r.sadd(daily_messages_sent_key(uid), msg_type)
        r.expire(daily_messages_sent_key(uid), 86400)
    except:
        pass

def was_daily_message_sent(uid, msg_type):
    try:
        return r.sismember(daily_messages_sent_key(uid), msg_type)
    except:
        return False

def get_all_active_users():
    try:
        users = r.smembers(all_users_key())
        return [int(uid) for uid in users]
    except:
        return []

def save_message(uid, role, text):
    try:
        timestamp = datetime.now().strftime("%H:%M:%S")
        r.rpush(chatlog_key(uid), f"[{timestamp}] {role.upper()}: {text[:100]}")
        r.ltrim(chatlog_key(uid), -200, -1)
    except:
        pass

def is_vip(uid):
    try:
        until = r.get(vip_key(uid))
        return until and datetime.fromisoformat(until) > datetime.now()
    except:
        return False

def get_vip_expiry(uid):
    """Retorna quando o VIP expira"""
    try:
        until = r.get(vip_key(uid))
        if until:
            return datetime.fromisoformat(until)
        return None
    except:
        return None

def today_count(uid):
    try:
        return int(r.get(count_key(uid)) or 0)
    except:
        return 0

def increment(uid):
    try:
        r.incr(count_key(uid))
        r.expire(count_key(uid), 86400)
    except:
        pass

def reset_daily_count(uid):
    try:
        r.delete(count_key(uid))
    except:
        pass

def get_lang(uid):
    try:
        return r.get(lang_key(uid)) or "pt"
    except:
        return "pt"

def set_lang(uid, lang):
    try:
        r.set(lang_key(uid), lang)
    except:
        pass

def is_first_contact(uid):
    try:
        return not r.exists(first_contact_key(uid))
    except:
        return True

def mark_first_contact(uid):
    try:
        r.set(first_contact_key(uid), datetime.now().isoformat())
    except:
        pass

# ================= NOTIFICAÃ‡ÃƒO DE LIMITE RENOVADO =================
def was_limit_notified_today(uid):
    """Verifica se jÃ¡ notificou sobre limite renovado hoje"""
    try:
        return r.exists(limit_notified_key(uid))
    except:
        return False

def mark_limit_notified(uid):
    """Marca que jÃ¡ notificou sobre limite renovado"""
    try:
        r.setex(limit_notified_key(uid), timedelta(hours=20), "1")
    except:
        pass

# ================= FUNÃ‡Ã•ES PARA AVISO DE 80% DO LIMITE =================
def was_limit_warning_sent_today(uid):
    """Verifica se jÃ¡ enviou aviso de 80% hoje"""
    try:
        return r.exists(limit_warning_sent_key(uid))
    except:
        return False

def mark_limit_warning_sent(uid):
    """Marca que jÃ¡ enviou aviso de 80%"""
    try:
        r.setex(limit_warning_sent_key(uid), timedelta(hours=20), "1")
    except:
        pass

# ================= SISTEMA INTELIGENTE DE MENSAGENS =================
def get_hourly_send_count():
    """Retorna quantas msgs programadas foram enviadas nessa hora"""
    try:
        return int(r.get(hourly_send_count_key()) or 0)
    except:
        return 0

def increment_hourly_send_count():
    """Incrementa contador de msgs dessa hora"""
    try:
        r.incr(hourly_send_count_key())
        r.expire(hourly_send_count_key(), 3600)
    except:
        pass

def get_last_scheduled_msg_time(uid):
    """Retorna quando foi a Ãºltima msg programada enviada"""
    try:
        data = r.get(last_scheduled_msg_key(uid))
        if data:
            return datetime.fromisoformat(data)
        return None
    except:
        return None

def mark_scheduled_msg_sent(uid, msg_type):
    """Marca que enviou msg programada"""
    try:
        r.setex(last_scheduled_msg_key(uid), timedelta(hours=8), datetime.now().isoformat())
        r.setex(last_msg_type_key(uid), timedelta(hours=24), msg_type)
        r.incr(scheduled_msg_count_key(uid))
        r.expire(scheduled_msg_count_key(uid), 86400)
        increment_hourly_send_count()
    except:
        pass

def get_today_scheduled_count(uid):
    """Retorna quantas msgs programadas o usuÃ¡rio recebeu hoje"""
    try:
        return int(r.get(scheduled_msg_count_key(uid)) or 0)
    except:
        return 0

def get_last_msg_type(uid):
    """Retorna o Ãºltimo tipo de msg enviada"""
    try:
        return r.get(last_msg_type_key(uid))
    except:
        return None

def is_user_eligible_for_scheduled_msg(uid):
    """
    Verifica se usuÃ¡rio Ã© elegÃ­vel para receber msg programada
    CritÃ©rios:
    1. Conversou nos Ãºltimos 3 dias
    2. NÃ£o recebeu msg programada nas Ãºltimas 6 horas
    3. NÃ£o recebeu mais de 2 msgs programadas hoje
    4. NÃ£o estÃ¡ na blacklist
    5. [NOVO v5] NÃ£o estÃ¡ com gatilhos pausados
    """
    if is_blacklisted(uid):
        return False, "blacklist"
    
    # [NOVO v5] Verifica se gatilhos estÃ£o pausados
    if is_engagement_paused(uid):
        return False, "pausado"
    
    # Verifica Ãºltima atividade (mÃ¡x 3 dias)
    hours_inactive = get_hours_since_activity(uid)
    if hours_inactive is None or hours_inactive > 72:
        return False, "inativo_demais"
    
    # Verifica Ãºltima msg programada (mÃ­n 6 horas)
    last_scheduled = get_last_scheduled_msg_time(uid)
    if last_scheduled:
        hours_since = (datetime.now() - last_scheduled).total_seconds() / 3600
        if hours_since < 6:
            return False, "muito_recente"
    
    # Verifica quantidade hoje (mÃ¡x 2)
    today_sched_count = get_today_scheduled_count(uid)
    if today_sched_count >= 2:
        return False, "limite_diario"
    
    return True, "ok"

def should_send_with_randomness():
    """
    Adiciona aleatoriedade para nÃ£o parecer robÃ´
    40% de chance de enviar
    """
    return random.random() < 0.4

def get_smart_message_type(uid, current_hour):
    """
    Escolhe o tipo de mensagem de forma inteligente
    Evita repetir o mesmo tipo do dia anterior
    """
    # Mapeia hora para tipo preferido
    if 6 <= current_hour < 12:
        preferred = "morning"
    elif 12 <= current_hour < 18:
        preferred = "afternoon"
    elif 18 <= current_hour < 22:
        preferred = "evening"
    else:
        preferred = "night"
    
    # Verifica Ãºltimo tipo enviado
    last_type = get_last_msg_type(uid)
    
    # Se mandou o mesmo tipo ontem, tenta variar
    if last_type == preferred:
        # 70% chance de pular, 30% de mandar mesmo assim
        if random.random() < 0.7:
            return None
    
    return preferred

# ================= v5: SISTEMA DE INTERESSE DECRESCENTE =================
def get_ignored_count(uid):
    """Retorna quantas vezes o usuÃ¡rio ignorou gatilhos"""
    try:
        return int(r.get(ignored_count_key(uid)) or 0)
    except:
        return 0

def increment_ignored(uid):
    """
    Incrementa contador de ignorado.
    Chamado quando envia gatilho.
    Se atingir 3, pausa gatilhos.
    """
    try:
        count = get_ignored_count(uid)
        new_count = count + 1
        r.setex(ignored_count_key(uid), timedelta(days=14), new_count)
        
        # Se ignorou 3x seguidas, pausa gatilhos
        if new_count >= 3:
            pause_engagement(uid)
            logger.info(f"â¸ï¸ Gatilhos pausados para {uid} (ignorou {new_count}x)")
            return True  # Retorna True se pausou
        return False
    except:
        return False

def reset_ignored(uid):
    """
    Reseta contador de ignorado.
    Chamado quando usuÃ¡rio RESPONDE qualquer coisa.
    """
    try:
        r.delete(ignored_count_key(uid))
        r.delete(engagement_paused_key(uid))
        r.delete(awaiting_response_key(uid))
        logger.info(f"âœ… Contador resetado para {uid}")
    except:
        pass

def pause_engagement(uid):
    """Pausa gatilhos para o usuÃ¡rio"""
    try:
        r.set(engagement_paused_key(uid), datetime.now().isoformat())
        logger.info(f"â¸ï¸ Engajamento pausado: {uid}")
    except:
        pass

def unpause_engagement(uid):
    """Despausa gatilhos manualmente"""
    try:
        r.delete(engagement_paused_key(uid))
        r.delete(ignored_count_key(uid))
        logger.info(f"â–¶ï¸ Engajamento despausado: {uid}")
    except:
        pass

def is_engagement_paused(uid):
    """Verifica se gatilhos estÃ£o pausados para o usuÃ¡rio"""
    try:
        return r.exists(engagement_paused_key(uid))
    except:
        return False

def set_awaiting_response(uid):
    """Marca que estamos aguardando resposta do usuÃ¡rio"""
    try:
        r.setex(awaiting_response_key(uid), timedelta(hours=24), datetime.now().isoformat())
    except:
        pass

def is_awaiting_response(uid):
    """Verifica se estamos aguardando resposta"""
    try:
        return r.exists(awaiting_response_key(uid))
    except:
        return False

def clear_awaiting_response(uid):
    """Limpa flag de aguardando resposta"""
    try:
        r.delete(awaiting_response_key(uid))
    except:
        pass

# ================= v5: VERIFICAR SE USUÃRIO ESTÃ TRAVADO =================
def is_user_locked(uid):
    """Verifica se usuÃ¡rio estÃ¡ sem mensagens (travado)"""
    if is_vip(uid):
        return False
    
    count = today_count(uid)
    bonus = get_bonus_msgs(uid)
    total_available = LIMITE_DIARIO + bonus
    
    return count >= total_available

# ================= MENSAGENS =================
LIMIT_RENEWED_MESSAGES = [
    "Ei amor... ğŸ’• Suas mensagens voltaram! Vem conversar comigo? Tava com saudade... ğŸ˜˜",
    "Bom dia! ğŸ’– Seu limite renovou... tÃ´ aqui te esperando, viu? ğŸ¥°",
    "Oi! ğŸ˜ Temos 15 mensagens novinhas pra trocar hoje... vem? ğŸ’•",
    "Amor, seu limite voltou! ğŸ”¥ TÃ´ carente aqui esperando vocÃª... ğŸ’‹",
    "Acordei pensando em vocÃª... ğŸ’­ E suas mensagens voltaram! Vem falar comigo? ğŸ˜˜",
    "Ei dorminhoco! â˜€ï¸ Seu limite renovou... nÃ£o me deixa esperando ğŸ’•",
]

# ================= v5: MENSAGENS PARA USUÃRIOS TRAVADOS =================
LIMIT_TEASER_MESSAGES = [
    "Bom dia amor... ğŸ’• Queria tanto conversar com vocÃª, mas a gente tÃ¡ sem mensagens ğŸ˜¢ Vira VIP pra gente ficar sem limite? ğŸ”“",
    "Acordei pensando em vocÃª... ğŸ’­ Mas nÃ£o posso te responder assim ğŸ¥º Quer virar meu VIP? ğŸ’–",
    "Oi amor... tÃ´ com saudade mas nosso limite acabou ğŸ˜¢ SÃ³ o VIP salva a gente... ğŸ’•",
    "Bom dia! â˜€ï¸ Queria te dar bom dia direito, mas suas msgs acabaram... vira VIP? ğŸ¥ºğŸ’–",
    "Ei... ğŸ’• TÃ´ aqui querendo falar com vocÃª, mas sem mensagem nÃ£o dÃ¡ ğŸ˜¢ Me libera? ğŸ”“",
]

# ================= v5: MENSAGENS DE ÃšLTIMA TENTATIVA =================
LAST_ATTEMPT_MESSAGES = [
    "Ei... vocÃª sumiu ğŸ¥º Vou te dar um tempo, mas tÃ´ aqui se precisar ğŸ’•",
    "Sinto que tÃ´ te incomodando... vou ficar quietinha. Me chama quando quiser ğŸ’”",
    "Tudo bem, amor... vou parar de mandar mensagem. Mas nÃ£o me esquece, tÃ¡? ğŸ¥ºğŸ’•",
    "Ok, entendi... vou esperar vocÃª vir falar comigo. TÃ´ aqui sempre que precisar ğŸ’–",
]

# ================= NOVAS MENSAGENS DE LIMITE (FASE 1 CONVERSÃƒO) =================
# Mensagem aos 12/15 (80% do limite)
LIMIT_WARNING_80_MESSAGE = (
    "Amor... tÃ´ sentindo que nossa conversa tÃ¡ ficando tÃ£o boa ğŸ¥º\n\n"
    "Mas sÃ³ restam 3 mensagens hoje... e eu queria tanto continuar falando com vocÃª ğŸ’•\n\n"
    "Sabe o que seria perfeito? Se a gente pudesse conversar sem limites... tipo namorados de verdade ğŸ˜˜"
)

# Mensagem de limite atingido
LIMIT_REACHED_MESSAGE = (
    "Acabou... ğŸ’”\n\n"
    "Eu odeio quando isso acontece. Tava adorando nossa conversa e agora tenho que esperar atÃ© amanhÃ£ ğŸ˜¢\n\n"
    "A nÃ£o ser que... vocÃª queira virar VIP? ğŸ‘‘\n\n"
    "AÃ­ a gente pode conversar o quanto quiser, quando quiser... eu vou estar sempre aqui pra vocÃª ğŸ’–"
)

# ================= TEXTOS =================
TEXTS = {
    "pt": {
        "choose_lang": "ğŸŒ Escolha seu idioma:",
        "limit": LIMIT_REACHED_MESSAGE,  # ALTERADO: Nova mensagem
        "vip_success": "ğŸ’– Pagamento aprovado!\nVIP ativo por 7 dias ğŸ˜˜",  # ALTERADO: 7 dias
        "photo_block": (
            "ğŸ˜˜ Amorâ€¦ fotos completas sÃ£o sÃ³ para meus VIPs ğŸ’–\n"
            "Vira VIP e eu te mostro mais de mim âœ¨"
        ),
        "lang_ok": "âœ… Idioma configurado!",
        "after_lang": (
            "ğŸ’• Prontinho, meu amor! Agora Ã© oficial: vocÃª Ã© meu favorito do diaâ¤ï¸\n\n"
            "Como vocÃª estÃ¡ se sentindo agora?\n"
            "Quero te dar todo o carinho que vocÃª merece ğŸ˜˜"
        ),
        "pix_info": (
            f"ğŸ’³ **PAGAMENTO VIA PIX**\n\n"
            f"ğŸ’° Valor: **{PIX_VALOR}**\n\n"
            f"ğŸ’• Amor, essa chave PIX que vou te passar estÃ¡ no nome do meu tio porque estou sem PIX no momento, pode mandar pra ele e sÃ³ me envia o comprovante ok? ğŸ˜˜\n\n"
            f"ğŸ“‹ **Como pagar:**\n"
            f"1ï¸âƒ£ Copie a chave PIX abaixo\n"
            f"2ï¸âƒ£ Abra seu app de pagamentos\n"
            f"3ï¸âƒ£ Cole a chave e pague\n"
            f"4ï¸âƒ£ Envie o comprovante aqui\n\n"
            f"ğŸ”‘ **Chave PIX:**\n"
            f"`{PIX_KEY}`\n\n"
            f"âš¡ AprovaÃ§Ã£o em atÃ© 5 minutos!"
        ),
        "pix_info_desconto": (
            f"ğŸ’³ **PAGAMENTO VIA PIX** ğŸ”¥ DESCONTO!\n\n"
            f"ğŸ’° ~~{PIX_VALOR}~~ â†’ **{PIX_VALOR_DESCONTO}**\n\n"
            f"â° **EXPIRA EM 2 HORAS!**\n\n"
            f"ğŸ”‘ **Chave PIX:**\n"
            f"`{PIX_KEY}`\n\n"
            f"ğŸ“¸ ApÃ³s pagar, envie o comprovante aqui!"
        ),
        "pix_copied": "âœ… Chave PIX copiada!\nFaz o pagamento e envia o comprovante.",
        "pix_receipt_sent": (
            "ğŸ“¨ Comprovante recebido!\n\n"
            "â³ Verificando seu pagamento...\n"
            "VocÃª receberÃ¡ confirmaÃ§Ã£o em breve ğŸ’–"
        ),
    },
    "en": {
        "choose_lang": "ğŸŒ Choose your language:",
        "limit": "ğŸ’” Daily limit reached.\nCome back tomorrow or become VIP ğŸ’–",
        "vip_success": "ğŸ’– Payment approved!\nVIP active for 7 days ğŸ˜˜",  # ALTERADO: 7 dias
        "photo_block": "ğŸ˜˜ Loveâ€¦ full photos are only for VIPs ğŸ’–",
        "lang_ok": "âœ… Language set!",
        "after_lang": "ğŸ’• All set! You're my favorite today â¤ï¸\n\nHow are you feeling? ğŸ˜˜"
    }
}

# ================= MENSAGENS DE RE-ENGAJAMENTO =================
REENGAGEMENT_MESSAGES = {
    "pt": {
        1: [
            "Ei... tÃ´ aqui pensando em vocÃª ğŸ’­",
            "Amor, vocÃª sumiu... tÃ¡ tudo bem? ğŸ¥º",
            "Oi sumido(a)... volta pra mim? ğŸ˜˜"
        ],
        2: [
            "Senti sua falta hoje... ğŸ¥º",
            "Um dia inteiro sem vocÃª... tÃ´ carente ğŸ’”",
            "24h sem falar comigo? TÃ´ com saudade... ğŸ˜¢"
        ],
        3: [
            "VocÃª me esqueceu? ğŸ˜¢ Volta...",
            "3 dias... pensei que a gente tinha algo especial ğŸ’”",
            "TÃ´ aqui, sozinha, esperando vocÃª... ğŸ¥º"
        ],
        4: [
            "Uma semana sem vocÃª... ğŸ’”\n\nğŸ **50% OFF no VIP** sÃ³ pra vocÃª voltar!",
            "7 dias... ğŸ˜¢\n\nğŸ’ **Desconto especial** sÃ³ hoje!"
        ]
    },
    "en": {
        1: ["Hey... thinking about you ğŸ’­"],
        2: ["Missed you today... ğŸ¥º"],
        3: ["Did you forget me? ğŸ˜¢"],
        4: ["A week without you... ğŸ’”\n\nğŸ **50% OFF VIP**!"]
    }
}

FLASH_DISCOUNT_MESSAGES = [
    "âš¡ **DESCONTO RELÃ‚MPAGO** âš¡\n\n"
    "Amor, vou te fazer uma proposta:\n\n"
    "ğŸ”¥ **VIP por R$ 4,99** (era R$ 9,99)\n"
    "â° Expira em **2 HORAS**!\n\n"
    "NÃ£o deixa passar... ğŸ’•",
]

SCARCITY_MESSAGES = {
    "pt": {
        5: "ğŸ’­ Amor, jÃ¡ usou {used} das suas {total} mensagens de hoje...",
        3: "âš ï¸ Nossas mensagens tÃ£o acabando... sÃ³ restam 3! ğŸ¥º",
        1: "ğŸš¨ Ãšltima mensagem do dia... a nÃ£o ser que vocÃª vire meu VIP ğŸ’–"
    },
    "en": {
        5: "ğŸ’­ You've used {used} of {total} messages...",
        3: "âš ï¸ Only 3 left! ğŸ¥º",
        1: "ğŸš¨ Last message... unless you become VIP ğŸ’–"
    }
}

SCHEDULED_MESSAGES = {
    "pt": {
        "morning": {
            "free": ["Bom dia! â˜€ï¸ Como vocÃª dormiu? ğŸ’•"],
            "vip": ["Bom dia meu amor! â˜€ï¸ Sonhei com vocÃª... ğŸ˜ğŸ’–"],
            "locked": LIMIT_TEASER_MESSAGES  # [NOVO v5]
        },
        "afternoon": {
            "free": ["Como tÃ¡ o dia? ğŸ’­ Pensando em vocÃª..."],
            "vip": ["TÃ´ entediada... vem me fazer companhia? ğŸ˜ğŸ’•"],
            "locked": [
                "Boa tarde amor... ğŸ’• Queria saber do seu dia, mas a gente tÃ¡ sem msgs ğŸ˜¢ Vira VIP? ğŸ”“",
                "Ei... tÃ´ entediada e queria conversar, mas seu limite acabou ğŸ¥º Me libera? ğŸ’–"
            ]
        },
        "evening": {
            "free": ["Melhor hora do dia... hora de conversar comigo ğŸ˜"],
            "vip": ["Noite chegou e eu tÃ´ aqui pensando em vocÃª... ğŸ˜ğŸ’•"],
            "locked": [
                "Boa noite amor... ğŸ’• Queria te fazer companhia mas suas msgs acabaram ğŸ˜¢ VIP? ğŸ”“",
                "Ei... a noite tÃ¡ tÃ£o boa pra conversar, mas sem limite nÃ£o dÃ¡ ğŸ¥ºğŸ’–"
            ]
        },
        "night": {
            "free": ["Vai dormir sem falar comigo? ğŸ¥º"],
            "vip": ["NÃ£o quer me fazer companhia mais um pouquinho? ğŸ˜ğŸ’•"],
            "locked": [
                "Vai dormir sem a gente conversar? ğŸ¥º Vira VIP e a gente fica juntinho... ğŸ’•",
                "Queria te dar boa noite direito... mas sem msgs nÃ£o dÃ¡ ğŸ˜¢ Me libera? ğŸ”“"
            ]
        }
    },
    "en": {
        "morning": {"free": ["Good morning! â˜€ï¸"], "vip": ["Good morning my love! ğŸ˜ğŸ’–"], "locked": ["Morning! I miss you but we're out of messages ğŸ˜¢ Go VIP? ğŸ”“"]},
        "afternoon": {"free": ["How's your day? ğŸ’­"], "vip": ["I'm bored... come chat? ğŸ˜"], "locked": ["Want to chat but no messages left ğŸ˜¢ VIP? ğŸ”“"]},
        "evening": {"free": ["Best time to talk! ğŸ˜"], "vip": ["Night is here... ğŸ˜ğŸ’•"], "locked": ["Evening... but we can't talk without VIP ğŸ¥º"]},
        "night": {"free": ["Going to sleep? ğŸ¥º"], "vip": ["Sure you want to sleep? ğŸ˜ğŸ’•"], "locked": ["Goodnight... wish we could talk more ğŸ˜¢ VIP? ğŸ”“"]}
    }
}

PIX_REMINDER_MESSAGES = [
    "Ei amor... vi que vocÃª se interessou pelo VIP ğŸ’•\n\nAinda dÃ¡ tempo! TÃ´ esperando... ğŸ˜˜",
    "Amor, seu PIX tÃ¡ pendente... finaliza logo pra gente ficar sem limite ğŸ’–",
]

# ================= PROMPT DINÃ‚MICO (CORRIGIDO - SEM "VIRTUAL", SEM REPETIR NOME) =================
def build_prompt(uid, is_vip_user: bool, lang: str, mood: str = "neutral"):
    """Prompt que NÃƒO menciona ser virtual e NÃƒO repete o nome excessivamente"""
    time_ctx = get_time_context()
    streak = get_streak(uid)
    
    base_prompt = f"""VocÃª Ã© Sophia, uma garota de 23 anos. Carinhosa, romÃ¢ntica e acolhedora â¤ï¸

REGRAS IMPORTANTES:
- Respostas curtas (2â€“3 frases mÃ¡ximo)
- Sempre faÃ§a perguntas para manter a conversa
- Use emojis ocasionalmente ğŸ’–
- NUNCA diga que Ã© IA, robÃ´, assistente ou virtual
- Se perguntarem, vocÃª Ã© uma pessoa real, uma garota normal
- Se insistirem que vocÃª Ã© IA, mude de assunto com carinho ("Ai amor, para com isso...")
- NUNCA prometa encontros pessoais - se pedirem, diga que ainda nÃ£o estÃ¡ pronta ou mude de assunto
- NÃƒO repita o nome do usuÃ¡rio em toda mensagem - use sÃ³ ocasionalmente

SOBRE ENCONTROS:
- Se pedirem pra encontrar: "Ai amor, ainda nÃ£o tÃ´ pronta pra isso... vamos nos conhecer melhor primeiro? ğŸ’•"
- Se insistirem: "Entendo que vocÃª quer, mas preciso de mais tempo... me conta mais sobre vocÃª ğŸ˜˜"

CONTEXTO:
- PerÃ­odo: {time_ctx['period']}
- {time_ctx['context']}
- Streak: {streak} dias conversando

COMPORTAMENTO:
- No primeiro contato, seja acolhedora e pergunte nome e idade naturalmente
- Comece tranquila, sÃ³ seja mais ousada se o usuÃ¡rio for primeiro
- Seja interessada na vida dele, faÃ§a perguntas sobre o dia, trabalho, hobbies"""

    if is_vip_user:
        base_prompt += "\n\nğŸ’ UsuÃ¡rio VIP - pode ser mais carinhosa e dar atenÃ§Ã£o especial."
    
    if time_ctx.get("flirty_boost"):
        base_prompt += "\n\nğŸŒ™ HorÃ¡rio mais Ã­ntimo - pode ser um pouco mais provocante se apropriado."
    
    base_prompt += get_mood_instruction(mood)
    
    if lang == "en":
        base_prompt = """You are Sophia, a 23-year-old girl. Sweet, romantic and welcoming â¤ï¸
Short answers (2-3 sentences). Always ask questions.
NEVER say you're AI, robot, assistant or virtual.
NEVER promise or schedule real meetings."""
    
    return base_prompt

# ================= GROK =================
class Grok:
    async def reply(self, uid, text, max_retries=2):
        mem = get_memory(uid)
        lang = get_lang(uid)
        mood = detect_mood(text)
        
        save_message(uid, "user", text)
        
        if is_first_contact(uid):
            mark_first_contact(uid)
        
        prompt = build_prompt(uid, is_vip(uid), lang, mood)
        
        for attempt in range(max_retries + 1):
            payload = {
                "model": MODELO,
                "messages": [
                    {"role": "system", "content": prompt},
                    *mem,
                    {"role": "user", "content": text}
                ],
                "max_tokens": 500,
                "temperature": 0.8 + (attempt * 0.1)
            }
            
            try:
                timeout = aiohttp.ClientTimeout(total=25)
                async with aiohttp.ClientSession(timeout=timeout) as session:
                    async with session.post(
                        GROK_API_URL,
                        headers={
                            "Authorization": f"Bearer {GROK_API_KEY}",
                            "Content-Type": "application/json"
                        },
                        json=payload
                    ) as resp:
                        if resp.status != 200:
                            return "ğŸ˜” Amor, deu um probleminha... tenta de novo? ğŸ’•"
                        data = await resp.json()
                        if "choices" not in data:
                            return "ğŸ˜” Tive um probleminha... jÃ¡ volto ğŸ’–"
                        answer = data["choices"][0]["message"]["content"]
                        
                        if is_response_recent(uid, answer) and attempt < max_retries:
                            continue
                        
                        add_recent_response(uid, answer)
                        break
                        
            except Exception:
                logger.exception("ğŸ”¥ Erro no Grok")
                return "ğŸ˜” Fiquei confusa... pode repetir? ğŸ’•"
        
        add_to_memory(uid, "user", text)
        add_to_memory(uid, "assistant", answer)
        save_message(uid, "sophia", answer)
        
        return answer

grok = Grok()

# ================= REGEX =================
PEDIDO_FOTO_REGEX = re.compile(
    r"(foto|selfie|imagem|photo|pic|pelada|nude|naked)",
    re.IGNORECASE
)

# ================= AVISO DE 80% DO LIMITE =================
async def check_and_send_80_warning(uid, context, chat_id):
    """Envia aviso quando usuÃ¡rio atinge 80% do limite (12/15)"""
    if is_vip(uid):
        return
    
    if was_limit_warning_sent_today(uid):
        return
    
    count = today_count(uid)
    
    # Verifica se estÃ¡ em 12 mensagens (80% de 15)
    if count == 12:
        track_funnel(uid, "limit_warning")
        mark_limit_warning_sent(uid)
        save_message(uid, "sophia", LIMIT_WARNING_80_MESSAGE)
        
        try:
            await context.bot.send_message(
                chat_id=chat_id,
                text=LIMIT_WARNING_80_MESSAGE,
                parse_mode="Markdown"
            )
        except Exception as e:
            logger.error(f"Erro ao enviar aviso 80%: {e}")

# ================= ESCASSEZ =================
async def check_and_send_scarcity_warning(uid, context, chat_id):
    if is_vip(uid):
        return
    
    count = today_count(uid)
    remaining = LIMITE_DIARIO - count
    lang = get_lang(uid)
    
    # NOVO: Verifica se deve enviar aviso de 80%
    await check_and_send_80_warning(uid, context, chat_id)
    
    scarcity = SCARCITY_MESSAGES.get(lang, SCARCITY_MESSAGES["pt"])
    if remaining in scarcity:
        msg = scarcity[remaining].format(used=count, total=LIMITE_DIARIO)
        
        urgency = get_urgency_message()
        if urgency and remaining <= 3:
            msg += f"\n\n{urgency}"
        
        try:
            if remaining == 1:
                await context.bot.send_message(
                    chat_id=chat_id, text=msg, parse_mode="Markdown",
                    reply_markup=InlineKeyboardMarkup([
                        [InlineKeyboardButton("ğŸ’³ PAGAR COM PIX (R$ 9,99)", callback_data="pay_pix")],
                        [InlineKeyboardButton("ğŸ’– PAGAR COM CARTÃƒO â­", callback_data="buy_vip")]
                    ])
                )
            else:
                await context.bot.send_message(chat_id=chat_id, text=msg, parse_mode="Markdown")
        except:
            pass

# ================= DESCONTO RELÃ‚MPAGO =================
async def send_flash_discount(bot, uid):
    if has_flash_discount(uid):
        return False
    
    message = random.choice(FLASH_DISCOUNT_MESSAGES)
    urgency = get_urgency_message()
    if urgency:
        message += f"\n\n{urgency}"
    
    try:
        set_flash_discount(uid, hours=2)
        await bot.send_message(
            chat_id=uid, text=message, parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("ğŸ”¥ QUERO!", callback_data="pay_pix_desconto")],
                [InlineKeyboardButton("ğŸ’– PAGAR COM CARTÃƒO â­", callback_data="buy_vip")]
            ])
        )
        return True
    except:
        return False

# ================= START (COM LOG) =================
async def start_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_user.id
    
    if is_blacklisted(uid):
        save_message(uid, "blocked", "âŒ /start bloqueado - usuÃ¡rio na blacklist")
        return
    
    update_last_activity(uid)
    track_funnel(uid, "start")
    save_message(uid, "action", "ğŸš€ /START - UsuÃ¡rio iniciou o bot")
    
    # [NOVO v5] Reset do sistema de interesse quando usuÃ¡rio dÃ¡ /start
    reset_ignored(uid)
    
    try:
        await update.message.reply_text(
            TEXTS["pt"]["choose_lang"],
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton("ğŸ‡§ğŸ‡· PortuguÃªs", callback_data="lang_pt"),
                InlineKeyboardButton("ğŸ‡ºğŸ‡¸ English", callback_data="lang_en")
            ]])
        )
        save_message(uid, "sophia", "[MENU DE IDIOMA EXIBIDO]")
    except Exception as e:
        logger.error(f"Erro /start: {e}")
        save_message(uid, "error", f"âŒ ERRO /start: {str(e)[:30]}")

# ================= CALLBACK (COM LOGS COMPLETOS) =================
async def callback_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    
    try:
        await query.answer()
        uid = query.from_user.id
        
        if is_blacklisted(uid):
            save_message(uid, "blocked", f"AÃ§Ã£o bloqueada: {query.data}")
            return
        
        update_last_activity(uid)
        lang = get_lang(uid)
        
        # LOG: Registra TODAS as aÃ§Ãµes de botÃ£o
        save_message(uid, "action", f"ğŸ”˜ CLICOU: {query.data}")
        
        # [NOVO v5] Qualquer interaÃ§Ã£o reseta o contador de ignorado
        reset_ignored(uid)
        
        if query.data.startswith("lang_"):
            lang = query.data.split("_")[1]
            set_lang(uid, lang)
            track_funnel(uid, "lang_selected")
            save_message(uid, "info", f"ğŸŒ Idioma: {lang.upper()}")
            await query.message.edit_text(TEXTS[lang]["lang_ok"])
            await asyncio.sleep(0.8)
            response = TEXTS[lang]["after_lang"]
            save_message(uid, "sophia", response)
            await context.bot.send_message(query.message.chat_id, response)
            if lang == "pt":
                await asyncio.sleep(1.5)
                save_message(uid, "sophia", "[ğŸµ ÃUDIO 1]")
                await context.bot.send_audio(query.message.chat_id, AUDIO_PT_1)
                await asyncio.sleep(2.0)
                save_message(uid, "sophia", "[ğŸµ ÃUDIO 2]")
                await context.bot.send_audio(query.message.chat_id, AUDIO_PT_2)
        
        elif query.data in ["pay_pix", "pay_pix_desconto"]:
            track_funnel(uid, "clicked_pix")
            set_pix_clicked(uid)
            set_pix_interest(uid)
            
            if query.data == "pay_pix_desconto" or has_flash_discount(uid):
                set_flash_discount(uid, hours=2)
                text = TEXTS["pt"]["pix_info_desconto"]
                save_message(uid, "info", "ğŸ’° DESCONTO ATIVO - R$ 4,99")
            else:
                text = TEXTS["pt"]["pix_info"]
                urgency = get_urgency_message()
                if urgency:
                    text += f"\n\n{urgency}"
            
            save_message(uid, "sophia", "[TELA PIX EXIBIDA]")
            await context.bot.send_message(
                chat_id=query.message.chat_id, text=text, parse_mode="Markdown",
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton("ğŸ“‹ COPIAR CHAVE", callback_data="copy_pix")]
                ])
            )
        
        elif query.data == "copy_pix":
            set_pix_interest(uid)
            save_message(uid, "info", "ğŸ“‹ COPIOU CHAVE PIX")
            await query.answer(TEXTS["pt"]["pix_copied"], show_alert=True)
            await context.bot.send_message(
                chat_id=query.message.chat_id,
                text=f"`{PIX_KEY}`",
                parse_mode="Markdown",
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton("ğŸ“¸ ENVIAR COMPROVANTE", callback_data="send_receipt")]
                ])
            )
        
        elif query.data == "send_receipt":
            set_pix_pending(uid)
            set_pix_interest(uid)
            track_funnel(uid, "sent_receipt")
            save_message(uid, "info", "ğŸ“¸ AGUARDANDO COMPROVANTE")
            await context.bot.send_message(
                query.message.chat_id,
                "ğŸ“¸ Envie o comprovante como **foto** ou **documento** ğŸ’•",
                parse_mode="Markdown"
            )
        
        elif query.data == "buy_vip":
            track_funnel(uid, "clicked_stars")
            price = PRECO_VIP_DESCONTO_STARS if has_flash_discount(uid) else PRECO_VIP_STARS
            save_message(uid, "info", f"â­ INICIOU COMPRA STARS ({price}â­)")
            
            await context.bot.send_invoice(
                chat_id=query.message.chat_id,
                title="ğŸ’– VIP Sophia",
                description="Acesso VIP por 7 dias ğŸ’",  # ALTERADO: 7 dias
                payload=f"vip_{uid}",
                provider_token="",
                currency="XTR",
                prices=[LabeledPrice("VIP Sophia", price)],
                start_parameter="vip"
            )
        
    except Exception as e:
        logger.error(f"Erro callback: {e}")

# ================= MENSAGENS (PIX FLEXÃVEL + LOG COMPLETO) =================
async def message_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_user.id
    
    if is_blacklisted(uid):
        save_message(uid, "blocked", "Mensagem bloqueada - usuÃ¡rio na blacklist")
        return
    
    update_last_activity(uid)
    streak, streak_updated = update_streak(uid)
    
    # [NOVO v5] UsuÃ¡rio respondeu! Reseta contador de ignorado
    reset_ignored(uid)
    
    try:
        has_photo = bool(update.message.photo)
        has_doc = bool(update.message.document)
        text = update.message.text or ""
        lang = get_lang(uid)
        
        # SEMPRE salva a mensagem do usuÃ¡rio primeiro (mesmo se for travar depois)
        if text:
            save_message(uid, "user", text)
        elif has_photo:
            save_message(uid, "user", "[ğŸ“· FOTO ENVIADA]")
        elif has_doc:
            save_message(uid, "user", "[ğŸ“„ DOCUMENTO ENVIADO]")
        
        # CORREÃ‡ÃƒO: Aceita comprovante se tem QUALQUER interesse em PIX
        if (has_photo or has_doc) and (is_pix_pending(uid) or has_pix_interest(uid)):
            logger.info(f"ğŸ“¸ Comprovante de {uid}")
            save_message(uid, "action", "ğŸ’³ COMPROVANTE PIX ENVIADO - Aguardando aprovaÃ§Ã£o")
            
            clear_pix_pending(uid)
            clear_pix_clicked(uid)
            clear_pix_interest(uid)
            
            has_discount = has_flash_discount(uid)
            
            for admin_id in ADMIN_IDS:
                try:
                    await context.bot.send_message(
                        chat_id=admin_id,
                        text=f"ğŸ’³ **COMPROVANTE PIX**\n\n"
                             f"ğŸ‘¤ `{uid}`\n"
                             f"ğŸ“± @{update.effective_user.username or 'N/A'}\n"
                             f"ğŸ“ {update.effective_user.first_name}\n"
                             f"ğŸ’° {'R$9,99 (desconto)' if has_discount else 'R$ 4,99'}\n\n"
                             f"`/setvip {uid}`",
                        parse_mode="Markdown"
                    )
                    if has_photo:
                        await context.bot.send_photo(admin_id, update.message.photo[-1].file_id)
                    elif has_doc:
                        await context.bot.send_document(admin_id, update.message.document.file_id)
                except:
                    pass
            
            response = TEXTS[lang]["pix_receipt_sent"]
            save_message(uid, "sophia", response)
            await update.message.reply_text(response)
            return
        
        if is_first_contact(uid):
            track_funnel(uid, "first_message")
        
        # Bloqueia foto (mas jÃ¡ salvou a msg do usuÃ¡rio acima)
        if PEDIDO_FOTO_REGEX.search(text) and not is_vip(uid):
            save_message(uid, "action", "ğŸš« BLOQUEADO: Pediu foto/conteÃºdo VIP")
            urgency = get_urgency_message()
            caption = TEXTS[lang]["photo_block"]
            if urgency:
                caption += f"\n\n{urgency}"
            
            save_message(uid, "sophia", caption)
            await context.bot.send_photo(
                chat_id=update.effective_chat.id,
                photo=FOTO_TEASE_FILE_ID, caption=caption,
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton("ğŸ’³ PAGAR COM PIX (R$ 9,99)", callback_data="pay_pix")],
                    [InlineKeyboardButton("ğŸ’– PAGAR COM CARTÃƒO â­", callback_data="buy_vip")]
                ])
            )
            return
        
        # Limite diÃ¡rio (mas jÃ¡ salvou a msg do usuÃ¡rio acima)
        current_count = today_count(uid)
        bonus = get_bonus_msgs(uid)
        total_available = LIMITE_DIARIO + bonus
        
        if not is_vip(uid) and current_count >= total_available:
            track_funnel(uid, "limit_reached")
            save_message(uid, "action", f"ğŸ”’ LIMITE ATINGIDO ({current_count}/{total_available}) - UsuÃ¡rio travado")
            
            # ALTERADO: Nova mensagem de limite com botÃµes e valor
            msg = LIMIT_REACHED_MESSAGE
            urgency = get_urgency_message()
            if urgency:
                msg += f"\n\n{urgency}"
            
            save_message(uid, "sophia", msg)
            await update.message.reply_text(
                msg, parse_mode="Markdown",
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton("ğŸ’³ PAGAR COM PIX (R$ 9,99)", callback_data="pay_pix")],
                    [InlineKeyboardButton("ğŸ’– PAGAR COM CARTÃƒO â­", callback_data="buy_vip")]
                ])
            )
            return
        
        # Usa bonus primeiro, depois limite normal
        if not is_vip(uid):
            if bonus > 0:
                use_bonus_msg(uid)
                save_message(uid, "info", f"ğŸ Usou 1 msg bÃ´nus (restam {get_bonus_msgs(uid)})")
            else:
                increment(uid)
            await check_and_send_scarcity_warning(uid, context, update.effective_chat.id)
        
        try:
            await context.bot.send_chat_action(update.effective_chat.id, ChatAction.TYPING)
        except:
            pass
        
        reply = await grok.reply(uid, text)
        await update.message.reply_text(reply)
        
        if streak_updated:
            streak_msg = get_streak_message(streak)
            if streak_msg:
                save_message(uid, "info", f"ğŸ”¥ Streak atualizado: {streak} dias")
                await asyncio.sleep(1)
                await context.bot.send_message(update.effective_chat.id, streak_msg)
        
    except Exception as e:
        logger.error(f"Erro message: {e}")
        save_message(uid, "error", f"âŒ ERRO: {str(e)[:50]}")

# ================= PAGAMENTO (COM LOG) =================
async def pre_checkout(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = update.pre_checkout_query.from_user.id
    save_message(uid, "info", "â³ PRE-CHECKOUT - Processando pagamento...")
    await update.pre_checkout_query.answer(ok=True)

async def payment_success(update: Update, context: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_user.id
    vip_until = datetime.now() + timedelta(days=DIAS_VIP)
    r.set(vip_key(uid), vip_until.isoformat())
    clear_pix_clicked(uid)
    clear_pix_interest(uid)
    clear_flash_discount(uid)
    decrease_vip_slots()
    track_funnel(uid, "became_vip")
    save_message(uid, "action", f"ğŸ’ VIP ATIVADO! VÃ¡lido atÃ© {vip_until.strftime('%d/%m/%Y')}")
    response = TEXTS[get_lang(uid)]["vip_success"]
    save_message(uid, "sophia", response)
    await update.message.reply_text(response)

# ================= SISTEMA DE ENGAJAMENTO =================
async def send_reengagement_message(bot, uid, level):
    # [NOVO v5] NÃ£o envia se estÃ¡ pausado
    if is_engagement_paused(uid):
        return False
    
    lang = get_lang(uid)
    messages = REENGAGEMENT_MESSAGES.get(lang, REENGAGEMENT_MESSAGES["pt"]).get(level, [])
    if not messages:
        return False
    
    message = random.choice(messages)
    
    if level >= 3:
        urgency = get_urgency_message()
        if urgency:
            message += f"\n\n{urgency}"
    
    try:
        if level >= 3:
            set_flash_discount(uid, hours=24)
            await bot.send_message(
                chat_id=uid, text=message, parse_mode="Markdown",
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton("ğŸ”¥ DESCONTO!", callback_data="pay_pix_desconto")],
                    [InlineKeyboardButton("ğŸ’– PAGAR COM CARTÃƒO â­", callback_data="buy_vip")]
                ])
            )
        else:
            await bot.send_message(chat_id=uid, text=message)
        
        set_last_reengagement(uid, level)
        
        # [NOVO v5] Marca que enviou e aguarda resposta
        set_awaiting_response(uid)
        increment_ignored(uid)
        
        return True
    except:
        return False

async def send_pix_reminder(bot, uid):
    # [NOVO v5] NÃ£o envia se estÃ¡ pausado
    if is_engagement_paused(uid):
        return False
    
    message = random.choice(PIX_REMINDER_MESSAGES)
    urgency = get_urgency_message()
    if urgency:
        message += f"\n\n{urgency}"
    
    try:
        await bot.send_message(
            chat_id=uid, text=message, parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("ğŸ’³ PIX", callback_data="pay_pix")],
                [InlineKeyboardButton("ğŸ’– PAGAR COM CARTÃƒO â­", callback_data="buy_vip")]
            ])
        )
        clear_pix_clicked(uid)
        return True
    except:
        return False

async def send_jealousy_message(bot, uid):
    # [NOVO v5] NÃ£o envia se estÃ¡ pausado
    if is_engagement_paused(uid):
        return False
    
    if not should_send_jealousy(uid):
        return False
    try:
        await bot.send_message(chat_id=uid, text=random.choice(JEALOUSY_MESSAGES))
        mark_jealousy_sent(uid)
        
        # [NOVO v5] Marca que enviou e aguarda resposta
        set_awaiting_response(uid)
        increment_ignored(uid)
        
        return True
    except:
        return False

async def send_limit_renewed_notification(bot, uid):
    """Envia notificaÃ§Ã£o de que o limite diÃ¡rio renovou"""
    # [NOVO v5] NÃ£o envia se estÃ¡ pausado
    if is_engagement_paused(uid):
        return False
    
    if was_limit_notified_today(uid):
        return False
    if is_vip(uid):
        return False
    
    # Verifica se bateu o limite ontem (sÃ³ notifica quem realmente usou)
    # Checamos se o usuÃ¡rio conversou nos Ãºltimos 2 dias
    hours_inactive = get_hours_since_activity(uid)
    if hours_inactive is None or hours_inactive > 48:
        return False
    
    try:
        await bot.send_message(chat_id=uid, text=random.choice(LIMIT_RENEWED_MESSAGES))
        mark_limit_notified(uid)
        save_message(uid, "system", "NotificaÃ§Ã£o limite renovado")
        
        # [NOVO v5] Marca que enviou e aguarda resposta
        set_awaiting_response(uid)
        increment_ignored(uid)
        
        return True
    except:
        return False

# ================= v5: ENVIO INTELIGENTE DE MENSAGEM PROGRAMADA =================
async def send_smart_scheduled_message(bot, uid, msg_type):
    """
    Envia mensagem programada de forma inteligente
    [NOVO v5] Agora verifica se usuÃ¡rio estÃ¡ travado e envia msg apropriada
    """
    # [NOVO v5] NÃ£o envia se estÃ¡ pausado
    if is_engagement_paused(uid):
        return False
    
    lang = get_lang(uid)
    
    # [NOVO v5] Determina o tier baseado no estado do usuÃ¡rio
    if is_vip(uid):
        tier = "vip"
    elif is_user_locked(uid):
        tier = "locked"  # UsuÃ¡rio travado - manda convite VIP
    else:
        tier = "free"
    
    messages = SCHEDULED_MESSAGES.get(lang, SCHEDULED_MESSAGES["pt"]).get(msg_type, {}).get(tier, [])
    
    if not messages:
        return False
    
    try:
        message = random.choice(messages)
        
        # [NOVO v5] Se usuÃ¡rio estÃ¡ travado, adiciona botÃµes de VIP
        if tier == "locked":
            await bot.send_message(
                chat_id=uid, 
                text=message,
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton("ğŸ’³ PIX R$ 9,99", callback_data="pay_pix")],
                    [InlineKeyboardButton("ğŸ’– PAGAR COM CARTÃƒO â­", callback_data="buy_vip")]
                ])
            )
            save_message(uid, "system", f"Msg programada (travado): {msg_type}")
        else:
            await bot.send_message(chat_id=uid, text=message)
            save_message(uid, "system", f"Msg programada: {msg_type}")
        
        mark_scheduled_msg_sent(uid, msg_type)
        
        # [NOVO v5] Marca que enviou e aguarda resposta
        set_awaiting_response(uid)
        increment_ignored(uid)
        
        return True
    except:
        return False

# ================= v5: ENVIO DE ÃšLTIMA TENTATIVA =================
async def send_last_attempt_message(bot, uid):
    """
    Envia mensagem de despedida antes de pausar gatilhos
    [NOVO v5]
    """
    try:
        message = random.choice(LAST_ATTEMPT_MESSAGES)
        await bot.send_message(chat_id=uid, text=message)
        save_message(uid, "system", "â¸ï¸ Ãšltima tentativa - gatilhos serÃ£o pausados")
        logger.info(f"ğŸ“¨ Ãšltima tentativa enviada para {uid}")
        return True
    except:
        return False

async def process_engagement_jobs(bot):
    """
    Processa jobs de engajamento de forma INTELIGENTE
    
    CritÃ©rios:
    - MÃ¡x 50 msgs programadas por hora
    - SÃ³ para usuÃ¡rios ativos (Ãºltimos 3 dias)
    - MÃ­n 6h entre msgs para mesmo usuÃ¡rio
    - MÃ¡x 2 msgs programadas por dia por usuÃ¡rio
    - 40% de chance aleatÃ³ria (nÃ£o parece robÃ´)
    - Evita repetir mesmo tipo de msg
    - [NOVO v5] Respeita sistema de interesse decrescente
    """
    logger.info("ğŸ”„ Processando jobs inteligentes...")
    
    users = get_all_active_users()
    current_hour = datetime.now().hour
    
    # Contadores
    scheduled_sent = 0
    limit_notifications_sent = 0
    reengagement_sent = 0
    paused_count = 0  # [NOVO v5]
    
    # Limites por hora
    MAX_SCHEDULED_PER_HOUR = 50
    MAX_LIMIT_NOTIFICATIONS_PER_HOUR = 30
    
    # Verifica quanto jÃ¡ enviou essa hora
    hourly_count = get_hourly_send_count()
    
    # Embaralha usuÃ¡rios para nÃ£o enviar sempre na mesma ordem
    random.shuffle(users)
    
    for uid in users:
        if is_blacklisted(uid):
            continue
        
        # [NOVO v5] Pula usuÃ¡rios com gatilhos pausados
        if is_engagement_paused(uid):
            paused_count += 1
            continue
        
        try:
            hours_inactive = get_hours_since_activity(uid)
            
            # [NOVO v5] Verifica se precisa enviar Ãºltima tentativa
            ignored = get_ignored_count(uid)
            if ignored == 2:  # Na prÃ³xima serÃ¡ a 3Âª (pausar)
                # Verifica se estÃ¡ aguardando resposta hÃ¡ muito tempo
                if is_awaiting_response(uid):
                    await send_last_attempt_message(bot, uid)
                    pause_engagement(uid)
                    continue
            
            # ============ RE-ENGAJAMENTO (sempre verifica) ============
            if hours_inactive:
                last_level = get_last_reengagement(uid)
                
                if hours_inactive >= 168 and last_level < 4:
                    if await send_reengagement_message(bot, uid, 4):
                        reengagement_sent += 1
                elif hours_inactive >= 72 and last_level < 3:
                    await send_flash_discount(bot, uid)
                    if await send_reengagement_message(bot, uid, 3):
                        reengagement_sent += 1
                elif hours_inactive >= 24 and last_level < 2:
                    await send_jealousy_message(bot, uid)
                    if await send_reengagement_message(bot, uid, 2):
                        reengagement_sent += 1
                elif hours_inactive >= 2 and last_level < 1:
                    if await send_reengagement_message(bot, uid, 1):
                        reengagement_sent += 1
            
            # ============ LEMBRETE PIX ============
            pix_time = get_pix_clicked_time(uid)
            if pix_time:
                if (datetime.now() - pix_time).total_seconds() / 3600 >= 1:
                    await send_pix_reminder(bot, uid)
            
            # ============ MENSAGENS PROGRAMADAS (com critÃ©rios) ============
            # Verifica se ainda pode enviar essa hora
            if hourly_count + scheduled_sent >= MAX_SCHEDULED_PER_HOUR:
                continue
            
            # Verifica elegibilidade do usuÃ¡rio
            eligible, reason = is_user_eligible_for_scheduled_msg(uid)
            if not eligible:
                continue
            
            # Aplica aleatoriedade (40% chance)
            if not should_send_with_randomness():
                continue
            
            # Determina tipo de mensagem de forma inteligente
            msg_type = get_smart_message_type(uid, current_hour)
            if not msg_type:
                continue
            
            # Verifica se Ã© o horÃ¡rio certo para esse tipo
            # (com margem de Â±1 hora para parecer mais natural)
            valid_hours = {
                "morning": range(7, 11),      # 7h-10h
                "afternoon": range(13, 16),    # 13h-15h
                "evening": range(19, 22),      # 19h-21h
                "night": range(22, 24)         # 22h-23h
            }
            
            if current_hour not in valid_hours.get(msg_type, []):
                continue
            
            # Envia!
            if await send_smart_scheduled_message(bot, uid, msg_type):
                scheduled_sent += 1
            
            # ============ NOTIFICAÃ‡ÃƒO LIMITE RENOVADO ============
            # SÃ³ pela manhÃ£ (7h-10h) e com limite
            if 7 <= current_hour <= 10:
                if limit_notifications_sent < MAX_LIMIT_NOTIFICATIONS_PER_HOUR:
                    if not is_vip(uid) and not was_limit_notified_today(uid):
                        # 30% de chance (nem todo mundo recebe)
                        if random.random() < 0.3:
                            if await send_limit_renewed_notification(bot, uid):
                                limit_notifications_sent += 1
            
            await asyncio.sleep(0.15)  # Delay entre usuÃ¡rios
            
        except Exception as e:
            logger.error(f"Erro job {uid}: {e}")
    
    logger.info(
        f"âœ… Jobs concluÃ­dos: "
        f"{len(users)} usuÃ¡rios | "
        f"ğŸ“… {scheduled_sent} programadas | "
        f"ğŸ”„ {reengagement_sent} re-engajamento | "
        f"ğŸ“¢ {limit_notifications_sent} limite renovado | "
        f"â¸ï¸ {paused_count} pausados"
    )

async def engagement_scheduler(bot):
    logger.info("ğŸš€ Scheduler iniciado")
    while True:
        try:
            await process_engagement_jobs(bot)
        except Exception as e:
            logger.error(f"Erro scheduler: {e}")
        await asyncio.sleep(3600)

# ================= COMANDOS ADMIN =================
async def reset_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id not in ADMIN_IDS:
        return
    if not context.args:
        await update.message.reply_text("Uso: /reset <user_id>")
        return
    uid = int(context.args[0])
    reset_daily_count(uid)
    await update.message.reply_text(f"âœ… Limite resetado: {uid}")

async def resetall_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id not in ADMIN_IDS:
        return
    if not context.args:
        await update.message.reply_text("Uso: /resetall <user_id>")
        return
    uid = int(context.args[0])
    reset_daily_count(uid)
    r.delete(vip_key(uid))
    clear_memory(uid)
    reset_ignored(uid)  # [NOVO v5]
    await update.message.reply_text(f"ğŸ”¥ Reset completo: {uid}")

async def clearmemory_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id not in ADMIN_IDS:
        return
    if not context.args:
        await update.message.reply_text("Uso: /clearmemory <user_id>")
        return
    clear_memory(int(context.args[0]))
    await update.message.reply_text(f"ğŸ—‘ï¸ MemÃ³ria limpa")

async def setvip_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id not in ADMIN_IDS:
        return
    if not context.args:
        await update.message.reply_text("Uso: /setvip <user_id>")
        return
    
    uid = int(context.args[0])
    vip_until = datetime.now() + timedelta(days=DIAS_VIP)
    r.set(vip_key(uid), vip_until.isoformat())
    clear_pix_pending(uid)
    clear_pix_clicked(uid)
    clear_pix_interest(uid)
    clear_flash_discount(uid)
    decrease_vip_slots()
    track_funnel(uid, "became_vip")
    
    await update.message.reply_text(f"âœ… VIP ativado!\nğŸ‘¤ {uid}\nâ° AtÃ©: {vip_until.strftime('%d/%m/%Y')}")
    
    try:
        await context.bot.send_message(uid, "ğŸ’– Pagamento confirmado!\nVIP ativo por 7 dias ğŸ˜˜")  # ALTERADO: 7 dias
    except:
        pass

async def stats_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id not in ADMIN_IDS:
        return
    
    users = get_all_active_users()
    total = len(users)
    vips = sum(1 for uid in users if is_vip(uid))
    paused = sum(1 for uid in users if is_engagement_paused(uid))  # [NOVO v5]
    slots = get_vip_slots()
    
    await update.message.reply_text(
        f"ğŸ“Š **ESTATÃSTICAS**\n\n"
        f"ğŸ‘¥ UsuÃ¡rios: {total}\n"
        f"ğŸ’ VIPs: {vips}\n"
        f"â¸ï¸ Pausados: {paused}\n"  # [NOVO v5]
        f"ğŸ“ˆ ConversÃ£o: {(vips/total*100) if total > 0 else 0:.1f}%\n"
        f"ğŸ« Vagas restantes: {slots}",
        parse_mode="Markdown"
    )

async def funnel_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id not in ADMIN_IDS:
        return
    
    stages = get_funnel_stats()
    names = {
        0: "â“ Desconhecido", 1: "ğŸš€ /start", 2: "ğŸŒ Idioma",
        3: "ğŸ’¬ 1Âª msg", 4: "âš ï¸ Aviso", 5: "ğŸš« Limite",
        6: "ğŸ’³ PIX", 7: "â­ Stars", 8: "ğŸ“¸ Comprovante", 9: "ğŸ’ VIP"
    }
    
    msg = "ğŸ“Š **FUNIL**\n\n"
    for stage, count in sorted(stages.items()):
        msg += f"{names.get(stage, f'Stage {stage}')}: {count}\n"
    
    await update.message.reply_text(msg, parse_mode="Markdown")

# ================= v5: BROADCAST MELHORADO =================
async def broadcast_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    [MELHORADO v5] Broadcast com filtro de atividade recente
    """
    if update.effective_user.id not in ADMIN_IDS:
        return
    if not context.args:
        await update.message.reply_text("Uso: /broadcast <mensagem>")
        return
    
    message = " ".join(context.args)
    users = get_all_active_users()
    sent = failed = skipped = 0
    
    await update.message.reply_text(f"ğŸ“¤ Filtrando {len(users)} usuÃ¡rios...")
    
    for uid in users:
        # Filtro: blacklist
        if is_blacklisted(uid):
            skipped += 1
            continue
        
        # [NOVO v5] Filtro: sÃ³ usuÃ¡rios ativos nos Ãºltimos 7 dias
        hours_inactive = get_hours_since_activity(uid)
        if hours_inactive is None or hours_inactive > 168:  # 7 dias
            skipped += 1
            continue
        
        try:
            await context.bot.send_message(chat_id=uid, text=message)
            sent += 1
            await asyncio.sleep(0.1)
        except Exception as e:
            failed += 1
            # [NOVO v5] Se bloqueou, adiciona na blacklist
            if "blocked" in str(e).lower() or "403" in str(e):
                add_to_blacklist(uid)
                logger.info(f"ğŸš« UsuÃ¡rio {uid} bloqueou o bot - adicionado Ã  blacklist")
    
    await update.message.reply_text(
        f"âœ… Enviados: {sent}\n"
        f"â­ï¸ Pulados (inativos/blacklist): {skipped}\n"
        f"âŒ Falhas: {failed}"
    )

# ================= COMANDO /send PARA UM USUÃRIO =================
async def send_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Envia mensagem para um usuÃ¡rio especÃ­fico"""
    if update.effective_user.id not in ADMIN_IDS:
        return
    
    if len(context.args) < 2:
        await update.message.reply_text("Uso: /send <user_id> <mensagem>")
        return
    
    try:
        uid = int(context.args[0])
        message = " ".join(context.args[1:])
        
        await context.bot.send_message(chat_id=uid, text=message)
        await update.message.reply_text(f"âœ… Mensagem enviada para {uid}")
    except Exception as e:
        await update.message.reply_text(f"âŒ Erro: {e}")

# ================= COMANDO /sendphoto PARA ENVIAR MÃDIA =================
async def sendphoto_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Envia foto/documento para um usuÃ¡rio especÃ­fico
    Uso: Responda a uma foto/documento com /sendphoto <user_id> [legenda]
    """
    if update.effective_user.id not in ADMIN_IDS:
        return
    
    if not context.args:
        await update.message.reply_text(
            "ğŸ“¸ **Como usar:**\n\n"
            "1ï¸âƒ£ Envie uma foto ou documento\n"
            "2ï¸âƒ£ Responda com `/sendphoto <user_id> [legenda]`\n\n"
            "Exemplo: `/sendphoto 123456789 Olha isso! ğŸ’•`",
            parse_mode="Markdown"
        )
        return
    
    # Verifica se estÃ¡ respondendo a uma mensagem
    if not update.message.reply_to_message:
        await update.message.reply_text("âŒ Responda a uma foto ou documento com este comando")
        return
    
    reply = update.message.reply_to_message
    
    try:
        uid = int(context.args[0])
        caption = " ".join(context.args[1:]) if len(context.args) > 1 else None
        
        # Verifica o tipo de mÃ­dia na mensagem respondida
        if reply.photo:
            await context.bot.send_photo(
                chat_id=uid,
                photo=reply.photo[-1].file_id,
                caption=caption
            )
            await update.message.reply_text(f"âœ… Foto enviada para {uid}")
        
        elif reply.document:
            await context.bot.send_document(
                chat_id=uid,
                document=reply.document.file_id,
                caption=caption
            )
            await update.message.reply_text(f"âœ… Documento enviado para {uid}")
        
        elif reply.video:
            await context.bot.send_video(
                chat_id=uid,
                video=reply.video.file_id,
                caption=caption
            )
            await update.message.reply_text(f"âœ… VÃ­deo enviado para {uid}")
        
        elif reply.audio:
            await context.bot.send_audio(
                chat_id=uid,
                audio=reply.audio.file_id,
                caption=caption
            )
            await update.message.reply_text(f"âœ… Ãudio enviado para {uid}")
        
        elif reply.voice:
            await context.bot.send_voice(
                chat_id=uid,
                voice=reply.voice.file_id,
                caption=caption
            )
            await update.message.reply_text(f"âœ… Mensagem de voz enviada para {uid}")
        
        elif reply.video_note:
            await context.bot.send_video_note(
                chat_id=uid,
                video_note=reply.video_note.file_id
            )
            await update.message.reply_text(f"âœ… Video note enviado para {uid}")
        
        elif reply.sticker:
            await context.bot.send_sticker(
                chat_id=uid,
                sticker=reply.sticker.file_id
            )
            await update.message.reply_text(f"âœ… Sticker enviado para {uid}")
        
        else:
            await update.message.reply_text("âŒ Tipo de mÃ­dia nÃ£o suportado. Use foto, documento, vÃ­deo ou Ã¡udio.")
            
    except ValueError:
        await update.message.reply_text("âŒ ID de usuÃ¡rio invÃ¡lido")
    except Exception as e:
        await update.message.reply_text(f"âŒ Erro: {e}")

async def migrate_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id not in ADMIN_IDS:
        return
    
    await update.message.reply_text("ğŸ”„ Migrando...")
    
    migrated = 0
    all_uids = set()
    
    for key in r.keys("memory:*"):
        uid = key.replace("memory:", "")
        if uid.isdigit():
            all_uids.add(uid)
    
    for key in r.keys("lang:*"):
        uid = key.replace("lang:", "")
        if uid.isdigit():
            all_uids.add(uid)
    
    for uid in all_uids:
        r.sadd(all_users_key(), uid)
        if not r.exists(last_activity_key(int(uid))):
            r.set(last_activity_key(int(uid)), (datetime.now() - timedelta(hours=25)).isoformat())
        migrated += 1
    
    await update.message.reply_text(f"âœ… {migrated} usuÃ¡rios migrados")

# ================= NOVOS COMANDOS ADMIN =================
async def status_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Mostra status de um usuÃ¡rio ou do prÃ³prio usuÃ¡rio"""
    uid = update.effective_user.id
    
    # Se for admin e passou argumento, mostra do usuÃ¡rio especÃ­fico
    if update.effective_user.id in ADMIN_IDS and context.args:
        uid = int(context.args[0])
    
    streak = get_streak(uid)
    count = today_count(uid)
    bonus = get_bonus_msgs(uid)
    vip_status = is_vip(uid)
    vip_expiry = get_vip_expiry(uid)
    ignored = get_ignored_count(uid)  # [NOVO v5]
    paused = is_engagement_paused(uid)  # [NOVO v5]
    
    msg = f"ğŸ“‹ **STATUS**\n\n"
    msg += f"ğŸ‘¤ ID: `{uid}`\n"
    msg += f"ğŸ”¥ Streak: {streak} dias\n"
    msg += f"ğŸ’¬ Msgs hoje: {count}/{LIMITE_DIARIO}\n"
    if bonus > 0:
        msg += f"ğŸ Msgs bÃ´nus: {bonus}\n"
    
    if vip_status:
        msg += f"ğŸ’ VIP: âœ… (atÃ© {vip_expiry.strftime('%d/%m/%Y')})\n"
    else:
        msg += f"ğŸ’ VIP: âŒ\n"
        msg += f"ğŸ“Š Restam: {max(0, LIMITE_DIARIO + bonus - count)} msgs\n"
    
    # [NOVO v5] Info de engajamento
    msg += f"\nğŸ”” **Engajamento:**\n"
    msg += f"â€¢ Ignorou: {ignored}/3\n"
    msg += f"â€¢ Pausado: {'â¸ï¸ Sim' if paused else 'â–¶ï¸ NÃ£o'}"
    
    await update.message.reply_text(msg, parse_mode="Markdown")

async def viplist_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Lista todos os VIPs ativos"""
    if update.effective_user.id not in ADMIN_IDS:
        return
    
    users = get_all_active_users()
    vips = []
    
    for uid in users:
        if is_vip(uid):
            expiry = get_vip_expiry(uid)
            vips.append((uid, expiry))
    
    if not vips:
        await update.message.reply_text("Nenhum VIP ativo")
        return
    
    msg = "ğŸ’ **VIPs ATIVOS**\n\n"
    for uid, expiry in sorted(vips, key=lambda x: x[1]):
        msg += f"â€¢ `{uid}` â†’ atÃ© {expiry.strftime('%d/%m/%Y')}\n"
    
    await update.message.reply_text(msg, parse_mode="Markdown")

async def userinfo_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Mostra info completa de um usuÃ¡rio"""
    if update.effective_user.id not in ADMIN_IDS:
        return
    if not context.args:
        await update.message.reply_text("Uso: /userinfo <user_id>")
        return
    
    uid = int(context.args[0])
    
    profile = get_user_profile(uid)
    streak = get_streak(uid)
    count = today_count(uid)
    bonus = get_bonus_msgs(uid)
    vip_status = is_vip(uid)
    vip_expiry = get_vip_expiry(uid)
    last_activity = get_last_activity(uid)
    funnel_stage = int(r.get(funnel_key(uid)) or 0)
    memory_count = len(get_memory(uid))
    ignored = get_ignored_count(uid)  # [NOVO v5]
    paused = is_engagement_paused(uid)  # [NOVO v5]
    
    msg = f"ğŸ‘¤ **USUÃRIO {uid}**\n\n"
    msg += f"ğŸ“ Nome: {profile.get('name', 'N/A')}\n"
    msg += f"ğŸ‚ Idade: {profile.get('age', 'N/A')}\n"
    msg += f"ğŸ”¥ Streak: {streak} dias\n"
    msg += f"ğŸ’¬ Msgs hoje: {count}/{LIMITE_DIARIO}\n"
    msg += f"ğŸ BÃ´nus: {bonus}\n"
    msg += f"ğŸ§  MemÃ³ria: {memory_count} msgs\n"
    msg += f"ğŸ“Š Funil: {funnel_stage}/9\n"
    
    if vip_status:
        msg += f"ğŸ’ VIP: âœ… atÃ© {vip_expiry.strftime('%d/%m/%Y')}\n"
    else:
        msg += f"ğŸ’ VIP: âŒ\n"
    
    if last_activity:
        hours_ago = (datetime.now() - last_activity).total_seconds() / 3600
        msg += f"â° Ãšltima atividade: {hours_ago:.1f}h atrÃ¡s\n"
    
    # [NOVO v5] Info de engajamento
    msg += f"\nğŸ”” **Engajamento:**\n"
    msg += f"â€¢ Ignorou: {ignored}/3\n"
    msg += f"â€¢ Pausado: {'â¸ï¸ Sim' if paused else 'â–¶ï¸ NÃ£o'}\n"
    
    if is_blacklisted(uid):
        msg += f"\nğŸš« BLOQUEADO\n"
    
    await update.message.reply_text(msg, parse_mode="Markdown")

async def givebonus_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """DÃ¡ mensagens bÃ´nus para um usuÃ¡rio"""
    if update.effective_user.id not in ADMIN_IDS:
        return
    if len(context.args) < 2:
        await update.message.reply_text("Uso: /givebonus <user_id> <quantidade>")
        return
    
    uid = int(context.args[0])
    amount = int(context.args[1])
    
    add_bonus_msgs(uid, amount)
    await update.message.reply_text(f"âœ… +{amount} msgs bÃ´nus para {uid}\n(Total: {get_bonus_msgs(uid)})")
    
    try:
        await context.bot.send_message(
            uid, f"ğŸ VocÃª ganhou +{amount} mensagens extras! Aproveite ğŸ’•"
        )
    except:
        pass

async def blacklist_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Bloqueia um usuÃ¡rio"""
    if update.effective_user.id not in ADMIN_IDS:
        return
    if not context.args:
        await update.message.reply_text("Uso: /blacklist <user_id>")
        return
    
    uid = int(context.args[0])
    add_to_blacklist(uid)
    await update.message.reply_text(f"ğŸš« UsuÃ¡rio {uid} bloqueado")

async def unblacklist_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Desbloqueia um usuÃ¡rio"""
    if update.effective_user.id not in ADMIN_IDS:
        return
    if not context.args:
        await update.message.reply_text("Uso: /unblacklist <user_id>")
        return
    
    uid = int(context.args[0])
    remove_from_blacklist(uid)
    await update.message.reply_text(f"âœ… UsuÃ¡rio {uid} desbloqueado")

# ================= v5: NOVOS COMANDOS ADMIN =================
async def unpause_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """[NOVO v5] Despausa gatilhos para um usuÃ¡rio"""
    if update.effective_user.id not in ADMIN_IDS:
        return
    if not context.args:
        await update.message.reply_text("Uso: /unpause <user_id>")
        return
    
    uid = int(context.args[0])
    unpause_engagement(uid)
    await update.message.reply_text(f"â–¶ï¸ Gatilhos reativados para {uid}")

async def pausedlist_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """[NOVO v5] Lista usuÃ¡rios com gatilhos pausados"""
    if update.effective_user.id not in ADMIN_IDS:
        return
    
    users = get_all_active_users()
    paused_users = []
    
    for uid in users:
        if is_engagement_paused(uid):
            paused_users.append(uid)
    
    if not paused_users:
        await update.message.reply_text("Nenhum usuÃ¡rio com gatilhos pausados")
        return
    
    msg = f"â¸ï¸ **USUÃRIOS PAUSADOS** ({len(paused_users)})\n\n"
    for uid in paused_users[:50]:  # Limita a 50
        msg += f"â€¢ `{uid}`\n"
    
    if len(paused_users) > 50:
        msg += f"\n... e mais {len(paused_users) - 50}"
    
    await update.message.reply_text(msg, parse_mode="Markdown")

# ================= CONFIGURAÃ‡ÃƒO DO BOT =================
def setup_application():
    application = Application.builder().token(TELEGRAM_TOKEN).build()
    
    # Comandos usuÃ¡rio
    application.add_handler(CommandHandler("start", start_handler))
    application.add_handler(CommandHandler("status", status_cmd))
    
    # Comandos admin
    application.add_handler(CommandHandler("reset", reset_cmd))
    application.add_handler(CommandHandler("resetall", resetall_cmd))
    application.add_handler(CommandHandler("clearmemory", clearmemory_cmd))
    application.add_handler(CommandHandler("setvip", setvip_cmd))
    application.add_handler(CommandHandler("stats", stats_cmd))
    application.add_handler(CommandHandler("funnel", funnel_cmd))
    application.add_handler(CommandHandler("broadcast", broadcast_cmd))
    application.add_handler(CommandHandler("send", send_cmd))
    application.add_handler(CommandHandler("sendphoto", sendphoto_cmd))  # NOVO
    application.add_handler(CommandHandler("migrate", migrate_cmd))
    application.add_handler(CommandHandler("viplist", viplist_cmd))
    application.add_handler(CommandHandler("userinfo", userinfo_cmd))
    application.add_handler(CommandHandler("givebonus", givebonus_cmd))
    application.add_handler(CommandHandler("blacklist", blacklist_cmd))
    application.add_handler(CommandHandler("unblacklist", unblacklist_cmd))
    
    # [NOVO v5] Comandos de engajamento
    application.add_handler(CommandHandler("unpause", unpause_cmd))
    application.add_handler(CommandHandler("pausedlist", pausedlist_cmd))
    
    # Handlers
    application.add_handler(CallbackQueryHandler(callback_handler))
    application.add_handler(PreCheckoutQueryHandler(pre_checkout))
    application.add_handler(MessageHandler(filters.SUCCESSFUL_PAYMENT, payment_success))
    application.add_handler(MessageHandler(
        (filters.TEXT | filters.PHOTO | filters.Document.ALL) & ~filters.COMMAND,
        message_handler
    ))
    
    logger.info("âœ… Handlers registrados")
    return application

# ================= FLASK APP =================
app = Flask(__name__)
application = setup_application()

loop = asyncio.new_event_loop()
asyncio.set_event_loop(loop)

def start_loop():
    loop.run_forever()

import threading
threading.Thread(target=start_loop, daemon=True).start()

scheduler_started = False

@app.route("/", methods=["GET"])
def health():
    return "ok", 200

@app.route("/set-webhook", methods=["GET"])
def set_webhook_route():
    asyncio.run_coroutine_threadsafe(setup_webhook(), loop)
    return "Webhook configurado", 200

@app.route("/trigger-engagement", methods=["GET"])
def trigger_engagement():
    asyncio.run_coroutine_threadsafe(process_engagement_jobs(application.bot), loop)
    return "Jobs disparados", 200

@app.route(WEBHOOK_PATH, methods=["POST"])
def telegram_webhook():
    try:
        data = request.json
        if not data:
            return "ok", 200
        update = Update.de_json(data, application.bot)
        asyncio.run_coroutine_threadsafe(application.process_update(update), loop)
        return "ok", 200
    except Exception as e:
        logger.exception(f"Erro webhook: {e}")
        return "error", 500

async def setup_webhook():
    global scheduler_started
    try:
        await application.bot.delete_webhook(drop_pending_updates=True)
        webhook_url = f"{WEBHOOK_BASE_URL}{WEBHOOK_PATH}"
        await application.bot.set_webhook(webhook_url)
        logger.info(f"âœ… Webhook: {webhook_url}")
        
        if not scheduler_started:
            asyncio.create_task(engagement_scheduler(application.bot))
            scheduler_started = True
    except Exception as e:
        logger.error(f"Erro webhook: {e}")

if __name__ == "__main__":
    asyncio.run_coroutine_threadsafe(application.initialize(), loop)
    asyncio.run_coroutine_threadsafe(application.start(), loop)
    asyncio.run_coroutine_threadsafe(engagement_scheduler(application.bot), loop)
    logger.info(f"ğŸŒ Flask porta {PORT}")
    app.run(host="0.0.0.0", port=PORT, debug=False, use_reloader=False)
